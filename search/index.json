[{"content":"前言 学习网站:Starrycoding\n最小生成树 最小生成树用于处理无向图的最小权值和。\n生成树 对于一个无向图，若它的一个子图是包含该无向图全部顶点的树，那么该子图是该无向图的一个生成树。\n最小生成树 当连接顶点之间的边有权重时，权重之和最小的生成树则为最小生成树。\n最小生成树的实现有两种方法:\n基于点的Prim算法 基于边的Kruskal算法 Prim算法 朴素算法 对于一个无向图，我们选择一个点作为起点，一般选点1。（方便枚举） 我们用一个数组dist[]来记录所有点到起点的距离，初始化为正无穷。 我们用一个bool数组st[]来记录这个点是否已经被加入到生成树中。 我们用一个循环，每次循环中找到不在生成树中的距离起点最近的点，将这个点加入到生成树中。 当这个点加入进去，我们需要更新dist[]数组，将这个点的所有邻边的距离起点的距离更新一下。并且这个点的dist[]=0。 根据这个思路，我们可以写出朴素的Prim算法。时间复杂度为$O(n^2)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e3 + 9; //朴素算法能处理的范围很小 typedef long long ll; ll a[N][N], d[N]; bitset\u0026lt;N\u0026gt; intree; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(a, 0x3f, sizeof(a)); memset(d, 0x3f, sizeof(d)); for (int i = 1; i \u0026lt;= n; i++) { a[i][i] = 0; //自己到自己的距离为0 } for (int i = 1; i \u0026lt;= m; i++) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; a[u][v] = min(a[u][v], w); //用邻接表存无向图 a[v][u] = min(a[v][u], w); } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { int u = 1; // u就是我们要找的那个距离intree中的点最近的那个点,一开始就从1开始。 for (int j = 1; j \u0026lt;= n; j++) { if (intree[u] || (!intree[j] \u0026amp;\u0026amp; d[j] \u0026lt; d[u])) { u = j; } } if (i != 1) ans += d[u]; // 我们要把所有的权值加起来，但是第一个点是没有权值的，所以我们要特判一下。 intree[u] = true; d[u] = 0; for (int j = 1; j \u0026lt;= n; j++) // 每次生成树进入一个点都更新dist[]数组 { if (intree[j]) continue; d[j] = min(d[j], a[u][j]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 例题1 P72 【模板】最小生成树\n分析：\n题目的数据范围在$10^5$，所以我们用朴素的Prim算法是不能过的。我们该如何优化呢，观察循环，我们可以发现，我们每次循环中都要找到不在生成树中的距离起点最近的点，这个点我们可以用一个优先队列来维护，每次取出堆顶元素即可。这样我们就可以将时间复杂度优化到$O(nlogn)$。（和dijkstra很像）\n至于我们该如何入队，我们可以用一个循环来实现，每次循环中，我们将这个点的所有邻点的距离起点的距离更新一下。并且这个点的dist[]=0。假如邻点的dist[]变化了，那么他就有可能成为最近点，直接将他入队即可。\n之后我们就用优先队列来帮我们判断最近点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5 + 9; typedef long long ll; struct node { ll x; ll w; bool operator\u0026lt;(const node \u0026amp;b) const // 权值最小的优先，如果权值相同，那么用编号区分，编号小大无所谓 { return w == b.w ? x \u0026lt; b.x : w \u0026gt; b.w; } }; vector\u0026lt;vector\u0026lt;node\u0026gt;\u0026gt; g(N, vector\u0026lt;node\u0026gt;()); bitset\u0026lt;N\u0026gt; intree; ll d[N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(d, 0x3f, sizeof(d)); for (int i = 1; i \u0026lt;= m; i++) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; g[u].push_back({v, w}); g[v].push_back({u, w}); } ll ans = 0; priority_queue\u0026lt;node\u0026gt; pq; pq.push({1, 0}); d[1] = 0; while (pq.size()) { ll u = pq.top().x; // 取出来的点是距离当前intree中的点最近的一个 pq.pop(); if (intree[u]) { continue; } intree[u] = true; ans += d[u]; d[u] = 0; // 枚举所有出边 for (auto \u0026amp;edge : g[u]) { ll y = edge.x; ll w = edge.w; if (!intree[y] \u0026amp;\u0026amp; w \u0026lt; d[y]) //我们要取的是最小的权值，大的就不用入队了，并且已经在生成树的点也是肯定不能进的. { d[y] = w; pq.push({y, d[y]}); } } } for (int i = 1; i \u0026lt;= n; i++) // 最后判断一下是否所有的点都在生成树中,如果有一个点不在生成树中，那么就不构成生成树了，输出-1。 { if (!intree[i]) { ans = -1; break; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } Kruskal算法 kruskal算法是基于边的算法，它的思想是根据权值从小到大将边进行联通（用并查集），如果这条边的两个点已经联通了，那么这条边就不能加入到生成树中。\n这种算法就是一种贪心的算法，它的时间复杂度为$O(mlogm)$。m指的是边的数量。\n下面演示一下kruskal算法的过程：\n首先我们将所有的边按照权值从小到大排序。然后我们从权值最小的边开始，将这条边的两个点进行联通。如图是将1和2联通。接着再将2和4联通。就这样一直进行下去。直到所有的点都联通。\n例题2 P72 【模板】最小生成树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5 + 9; typedef long long ll; struct node { ll u; ll v; ll w; bool operator\u0026lt;(const node \u0026amp;b) const // 权值最小的优先，如果权值相同就用编号区分，编号小大无所谓 { if (w != b.w) { return w \u0026lt; b.w; } if (u != b.u) { return u \u0026lt; b.u; } return v \u0026lt; b.v; } }; ll pre[N]; // 并查集 ll root(ll x) { if (pre[x] == x) { return x; } else { ll root_x = root(pre[x]); pre[x] = root_x; return root_x; } } void merge(ll x, ll y) { pre[root(x)] = root(y); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { pre[i] = i; } vector\u0026lt;node\u0026gt; es; // 用vector来存边，方便排序 for (int i = 1; i \u0026lt;= m; i++) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; es.push_back({u, v, w}); } ll ans = 0; sort(es.begin(), es.end()); for (auto \u0026amp;e : es) { ll u = e.u; ll v = e.v; ll w = e.w; if (root(u) == root(v)) // 如果两个点已经联通了，那么这条边就不能加入到生成树中 { continue; } merge(u, v); // 将这两个点联通 ans += w; // 权值累加 } for (int i = 1; i \u0026lt;= n - 1; i++) { if (root(i) != root(i + 1)) // 最后判断一下是否所有的点都在生成树中,如果有一个点不在生成树中，那么就不构成生成树了，输出-1。 { ans = -1; break; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 总结 通常来说，我们更倾向使用kruskal算法，因为他实现很简单\nprim算法更适用于稠密图，kruskal算法更适用于稀疏图。\n稠密图就是点的数量少，边的数量很多，那么一个点的邻边就很多，prim适合这种情况。\n稀疏图就是点的数量多，边的数量少，那么一个点的邻边就很少，kruskal适合这种情况。\n质因数分解 质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。\n对于质数，我们要掌握:\n质数的判断 筛法 质数的判断 对于一个数n，我们只需要判断它是否能被$2\\sim \\sqrt{n}$中的数整除即可。如果能被整除，那么就不是质数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool isprime(int n) //质数判断 { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= n / i; i++) { if (n % i == 0) { return false; } } return true; } 因子分解 在讲质因数分解前，我们先讲一下因子分解。\nP16 【模板】求N的所有因子\n分析：\n由图，我们假设一个数$N=a\\times b$，那么a和b就是N的因子。\n不妨设$a\\leq b$，那么我们可以得到$a\\leq \\sqrt{N}\\leq b$。\n其中$b=N/a$。\n那么我们只要枚举$a$，找出其中整除$N$的数即可。假如这个数为$i$,那么$b=N/i$。\n我们可以用一个vector来存因子，最后排序输出即可。\n注意枚举范围为$1\\sim \\sqrt{N}$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { ll n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; v; for (ll i = 1; i \u0026lt;= n / i; i++) { if (n % i == 0) { // n与n/i两个因子 v.push_back(i); if (i != n / i) { v.push_back(n / i); } } } sort(v.begin(), v.end()); for (auto \u0026amp;i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 例题 P17 【模板】求N的所有质因子\n分析：\n对于求N的质因子，我们可以将N分解为多个质因子的乘积。\n例如：$12=2\\times 2\\times 3$\n所以我们只要从2开始枚举，判断能否整除，如果可以整除，那么就将这个质因子加入到vector中，并且将N持续除以这个数，直到N不能再被这个数整除。如此才会保证N是由多个质因子的乘积组成的。\n为何这样枚举得到的因子一定是质数呢？\n我们可以用一个反证法来证明。\n假如我们枚举到一个数$i$，但是$i$不是质数，那么$i$就可以被分解为多个质因子的乘积。即$i=a*b$为一个合数.既然$n$能被$i$整除，那么$n$也一定能被$a$和$b$整除。\n但是我们的枚举是从2开始的，所以$i$的因数一定会先于i被枚举到，假设这个先被枚举到的因数为$a$,$n$一定会被$a$整除,然后a就会被除光,除剩下的$n$就不再包含了$a$了，此时再枚举到$i$，$n$也不会再被$i$整除了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { ll n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; v; for (ll i = 2; i \u0026lt;= n / i; i++) // 枚举所有质因子 i肯定要从2开始 { if (n % i != 0) { continue; } // i为一个质因子 v.push_back(i); while (n % i == 0) { n /= i; // n除去所有i } } if (n \u0026gt; 1) { v.push_back(n); // 如果n\u0026gt;1,最后n他自己就是一个质因子 } sort(v.begin(), v.end()); for (auto \u0026amp;i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } ","date":"2025-01-25T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/cuixingshi_hu_b575be1af4f16ff1.jpg","permalink":"https://baoziandbluemouse.github.io/p/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/","title":"最小生成树，质因数分解"},{"content":"前言 学习网站:Starrycoding\n有关图的基本概念:oi wiki\n图的存储 在题目中，想要对图进行操作，就需要将图存储下来。\n常见的图的存储方式有：\n邻接矩阵 邻接表 邻接矩阵 邻接矩阵是一种用二维数组来表示图的方式。\n使用一个二维数组$a$来表示图，其中$a[i][j]$值为1表示存在从点$i$到点$j$的边，值为0表示不存在。如果是带有权值的图，那么$a[i][j]$值为权值。\n邻接表 邻接表的实现方式有两种，一种是链式前向星，另一种通过vector数组。\n我们这里介绍用vector数组实现的，这种方法也更方便排序。\n使用一个vector数组$a$来表示图，其中$a[i]$表示从点$i$出发的所有边。显而易见这是个二维数组。\n1 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(N, vector\u0026lt;int\u0026gt;()); // graph 假设我们要添加一条从点$u$到点$v$的边，那么我们可以这样：\n1 g[u].push_back(v); 假如还有一条从点$u$到点$w$的边，就再push_back一次即可.\n例题 P42 树的遍历\n分析：\n存储树，我们可以用一个数组来存储每个点的父节点。\n然后再用邻接表来存储树。只需要把父节点作为起点，子节点作为终点，添加一条边即可。最后就可以对树进行遍历了。注意此处要从小到大输出，所以我们可以对邻接表进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 60; int fa[N]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(N, vector\u0026lt;int\u0026gt;()); // graph void dfs(int x) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (auto \u0026amp;y : g[x]) { dfs(y); } } void bfs(int x) { queue\u0026lt;int\u0026gt; q; q.push(x); while (q.size()) { int x = q.front(); q.pop(); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (auto \u0026amp;y : g[x]) q.push(y); } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 2; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; fa[i]; } for (int i = 2; i \u0026lt;= n; i++) { g[fa[i]].push_back(i); } for (int i = 1; i \u0026lt;= n; i++) { sort(g[i].begin(), g[i].end()); } dfs(1); cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; bfs(1); return 0; } P64 图的遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5 + 9; bitset\u0026lt;N\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(N, vector\u0026lt;int\u0026gt;()); void dfs(int x) { vis[x] = true; for (auto \u0026amp;y : g[x]) { if (vis[y]) continue; dfs(y); } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); } dfs(1); for (int i = 1; i \u0026lt;= n; i++) { if (vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 并查集 并查集，并指合并，查指查询（联通关系），集指集合。\n并查集可以用来做联通块的问题。并查集的所有操作都是对根节点进行的。\n并查集的具体操作有：\n初始化：一个数组$pre$, 假设有点$u$和$v$，在一开始我们初始化认为这两个点是自环的，即$pre[u] = u, pre[v] = v$.因此初始化为$pre[i] = i$ root函数：通过这个函数找到一个点的根节点。最重要的函数. 合并：将两个点联通，实际就是将两个点的根节点合并。即$pre[root(u)] = root(v)$ 查询：查询两个点是否联通，即$root(u) == root(v)$ 朴素版root函数:\n1 2 3 4 5 6 7 int root(int x) { if (pre[x] == x) return x; else return root(pre[x]); // 递归找到根节点 } 朴素版的时间复杂度为$O(n)$，但是我们往往会查询很多点的root，这样的时间复杂度就会很高。因此我们需要优化root函数。\n路径压缩版root函数：\n我们在一次找到根节点后，其实就能将整条路径上的所有点的根节点都更新为根节点。这样就可以大大减少时间复杂度。我们只需要进行极少次的$O(n)$操作，后续都能是$O(1)$的。均摊下来时间复杂度就很小了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int root(int x) // 路径压缩实现寻找根节点，并将沿途的节点都指向根节点 { if (pre[x] == x) { return x; } else { int root_x = root(pre[x]); pre[x] = root_x; return root_x; } } 例题 P68 联通块问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 9; int pre[N], cnt[N]; int root(int x) // 路径压缩实现寻找根节点，并将沿途的节点都指向根节点 { if (pre[x] == x) { return x; } else { int root_x = root(pre[x]); pre[x] = root_x; return root_x; } } void merge(int x, int y) // 这里x和y的顺序是无所谓的,都正确 { pre[root(x)] = root(y); } bool isCon(int x, int y) // 判断x和y是否连通 { return root(x) == root(y); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { pre[i] = i; } for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; merge(u, v); } for (int i = 1; i \u0026lt;= n; i++) // 使用一个桶来统计每个连通块的大小 { cnt[root(i)]++; } vector\u0026lt;int\u0026gt; v; // 用vector方便排序 for (int i = 1; i \u0026lt;= n; i++) { if (cnt[i]) { v.push_back(cnt[i]); } } sort(v.begin(), v.end()); for (auto \u0026amp;y : v) { cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 最短路 普通的无权图的最短路问题，一般用BFS来解决。\n但是当我们遇到有权图的最短路问题时，就需要使用最短路算法来解决。\n常见的最短路算法有：\nDijkstra（处理单源最短路） Floyd(处理多源最短路) Dijkstra Dijkstra算法是一种贪心算法，它的思想是：每次都选择当前距离起点最近的点，然后更新它的邻居的距离。\nDijkstra算法的步骤：\n初始化一个数组$dis$，$dis[i]$表示从起点到点$i$的最短距离。初始化$dis[起点] = 0$，其他点的距离都为$inf$.\n初始化一个数组$vis$，$vis[i]$表示点$i$是否已经找到最短路径。如果已经找到了最短路径，那么$vis[i] = true$，这个点不需要再更新了。开始时就是$vis[起点] = true$\n松弛操作：我们从起点开始，每次选择当前距离起点最近的点，然后更新它的邻居的距离。即$dis[邻居] = min(dis[邻居], dis[当前点] + 边权)$.\n如图我们更新完二号和三号点后，一号的邻居点都已经更新完毕，接下来我们就要在这些邻居点中找到$d[i]$最小的点，这个点就是下一个起点，根据性质，这个点的$d[i]$一定是最小的。那么这个点的$vis[i]$就可以置为$true$了。如图，我们选择二号点作为起点继续更新。\n重复上述操作，直到所有点都找到最短路径。\n例题1 P69 【模板】最短路（1）\n这一题就是Dijkstra算法的模板题。但是是朴素版，时间复杂度是$O(n^2)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e3 + 9; typedef long long ll; struct node { int x, w; // x表示出点，w表示权值 }; vector\u0026lt;vector\u0026lt;node\u0026gt;\u0026gt; g(N, vector\u0026lt;node\u0026gt;()); ll d[N], n, m; void dijkstra(int st) { memset(d, 0x3f, sizeof(ll) * (n + 1)); d[st] = 0; bitset\u0026lt;N\u0026gt; vis; // 记录已经被拓展过的 for (int i = 1; i \u0026lt;= n - 1; i++) { // 找出最小点（距离源点最近的点） int u = 1; for (int j = 1; j \u0026lt;= n; j++) { if (vis[u] || (!vis[j] \u0026amp;\u0026amp; d[j] \u0026lt; d[u])) { u = j; } } // 表示u已被拓展 vis[u] = true; // 此时d[u]已为最优的，别的不一定 for (const auto \u0026amp;edge : g[u]) { int v = edge.x; int w = edge.w; if (!vis[v] \u0026amp;\u0026amp; d[v] \u0026gt; d[u] + w) { d[v] = d[u] + w; } } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u != v) // 避免自环 { g[u].push_back({v, w}); } } dijkstra(1); cout \u0026lt;\u0026lt; (d[n] \u0026gt;= 0x3f3f3f3f ? -1 : d[n]) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出d[n]，若d[n]未被更新，则输出-1(即d[n]\u0026gt;=0x3f3f3f3f) return 0; } 例题2 P70 【模板】最短路（2）\n上一题虽然我们实现了，但是时间复杂度实在难以接受，我们可以考虑使用堆优化的Dijkstra算法。(使用优先队列)时间复杂度为$O(m\\log m)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 for (int i = 1; i \u0026lt;= n - 1; i++) { // 找出最小点（距离源点最近的点） int u = 1; for (int j = 1; j \u0026lt;= n; j++) { if (vis[u] || (!vis[j] \u0026amp;\u0026amp; d[j] \u0026lt; d[u])) { u = j; } } // 表示u已被拓展 vis[u] = true; // 此时d[u]已为最优的，别的不一定 for (const auto \u0026amp;edge : g[u]) { int v = edge.x; int w = edge.w; if (!vis[v] \u0026amp;\u0026amp; d[v] \u0026gt; d[u] + w) { d[v] = d[u] + w; } } } 观察这个循环，我们可以发现，每次都要找到$d[i]$最小的点，这个过程是$O(n)$的。我们可以使用优先队列来优化这个过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void dijkstra(int st) { memset(d, 0x3f, sizeof(ll) * (n + 1)); d[st] = 0; bitset\u0026lt;N\u0026gt; vis; // 记录已经被拓展过的 priority_queue\u0026lt;node\u0026gt; pq; // 进入队列的点，按权值从小到大排序 pq.push({st, d[st]}); // 将源点加入优先队列 while (pq.size()) { int u = pq.top().x; pq.pop(); if (vis[u]) // 跳过冗余点 continue; vis[u] = true; // 标记u已得到最短距离，不再更新 for (const auto \u0026amp;edge : g[u]) { int v = edge.x; int w = edge.w; if (!vis[v] \u0026amp;\u0026amp; d[v] \u0026gt; d[u] + w) // 如果vis[v]为true，则该点已得到最短路径，无需更新 { d[v] = d[u] + w; pq.push({v, d[v]}); } } } } 还要注意的是，我们使用优先队列时，需要重载小于(\u0026lt;)号。\n1 2 3 4 5 6 7 8 9 struct node { ll x, w; // x表示出点，w表示权值 bool operator\u0026lt;(const node \u0026amp;v) const { return w == v.w ? (x \u0026lt; v.x) : (w \u0026gt; v.w); // 重载\u0026lt;运算符，(优先比较权值）w从小到大排序,若权值相等，则按x排序 // 注意优先队列的比较器是相反的，要小根堆，就得是w\u0026gt;v.w,和sort函数之类的比较器写法相反 } }; 可以看出，使用优先队列优化的Dijkstra算法和bfs是有点像的。\nFloyd Floyd算法是一种多源最短路算法，它的思想是：枚举中间点，然后更新所有点之间的距离。\n由于Floyd的高复杂度$O(n^3)$，所以数据范围一定会在$300$左右。\nFloyd的模板就是一个三重循环。\n1 2 3 4 5 6 7 8 9 10 for (int k = 1; k \u0026lt;= n; k++) //注意这个中间点必须放在第一层循环 { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } Floyd是一个很宏观的算法，它不会理会具体的路径，只是枚举所有的路径。然后找出最短的路径。\n例题 P71 【模板】最短路（3）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 350; typedef long long ll; const ll inf = 0x3f3f3f3f; ll d[N][N], n, m, q; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; memset(d, 0x3f, sizeof(d)); for (int i = 1; i \u0026lt;= m; i++) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; d[u][v] = min(d[u][v], w); // 存储最小的边权 } // 初始化 for (int i = 1; i \u0026lt;= n; i++) { d[i][i] = 0; // 自环为0 } for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } while (q--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; (d[u][v] \u0026gt;= inf ? -1 : d[u][v]); } return 0; } ","date":"2025-01-23T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9C%80%E7%9F%AD%E8%B7%AF/ok_hu_8830891c626e9b2a.jpg","permalink":"https://baoziandbluemouse.github.io/p/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9C%80%E7%9F%AD%E8%B7%AF/","title":"图的存储，并查集，最短路"},{"content":"前言 学习网站:Starrycoding\n离散化 离散化是一种处理数据的技巧,通俗地讲就是当我们需要处理的数据范围很大,但是数据的个数很少时,我们可以将数据的范围进行压缩,从而减少空间的占用。离散化是一种映射的思想。\n将一个数组离散化，并进行查询是比较常用的应用场景。\n离散化的步骤如下：\n选择好相关点，创建原数组的副本。 将副本中的值从小到大排序。 将排序好的副本去重。 查找原数组的每一个元素在副本中的位置，位置即为排名，将其作为离散化后的值。（我们一般用二分查找） 例题 P63 我的很长，你算一下\n分析：\n根据题目，数组的下标范围是$[1,10^9]$，这么大的范围如果我们直接用数组来存储会爆内存，根本连暴力都用不了。\n但是看到数据，个数只有$10^5$个，那么如果把下标作为值存储在数组中呢？\n我们把这个数组叫做X,这些下标叫做相关点,X的下标叫做排名。接着我们再开一个数组Y，Y的下标和X的下标一一对应，而Y的值存储的是原数组的值,也可以用来加减了。\n这样通过两个数组，我们就可以通过排名来查询原数组的值了。\n总结得到这样的映射关系:排名\u0026ndash;\u0026gt;原数组的下标\u0026ndash;\u0026gt;原数组的值\n所以我们可以将数组的下标进行离散化，然后用数组来存储。那么我们就有办法存储相关点了，也可以再用二分得到相关点的排名。\n这里要注意，既然离散化的是下标，那么q次询问中的l和r也要记录进X中.这样才能得到排名。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 3e5 + 9; ll arr[N]; vector\u0026lt;int\u0026gt; X; struct Q // 存放操作和询问 { ll a, b; } add[N], que[N]; ll getidx(int x) { /*lower_bound下边界 up_bound 上边界 由于计算机区间习惯左闭右开，所以lower_bound返回第一个等于x的元素（假如有），up_bound返回第一个大于x的元素 \u0026lt;x, \u0026lt;x, \u0026lt;x, [x, x, x, \u0026gt;x) ,\u0026gt;x lower_bound找出数组中第一个大于等于x元素的迭代器,up_bound返回的是第一个严格大于给定值的元素的迭代器。*/ return lower_bound(X.begin(), X.end(), x) - X.begin() + 1; // 返回值范围是[1,X.size()] } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { ll x, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; w; X.push_back(x); add[i] = {x, w}; } for (int i = 1; i \u0026lt;= q; i++) { ll l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; X.push_back(l); X.push_back(r); que[i] = {l, r}; } // 排序去重 sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end()); for (int i = 1; i \u0026lt;= n; i++) { ll x = getidx(add[i].a); ll w = add[i].b; arr[x] += w; } // 前缀和 for (int i = 1; i \u0026lt;= X.size(); i++) { arr[i] += arr[i - 1]; } for (int i = 1; i \u0026lt;= q; i++) { ll l = getidx(que[i].a); ll r = getidx(que[i].b); cout \u0026lt;\u0026lt; arr[r] - arr[l - 1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 树状数组 树状数组是一种支持单点修改,区间查询和区间修改（区间修改运用了差分）的，代码量小的数据结构。树状数组简单来说，算是一种高级前缀和。\n假如有个数组$a$，我们想得到这个数组的前缀和很简单，只需要用一个数组$sum$来存储前缀和就可以了。但是，如果我们要修改数组$a$中的一个元素，然后马上查询那个区间的和，那么我们$sum$就要重新进行前缀和再输出，这样的话，时间复杂度就会很高。\n想解决这种在线的单点修改，就得使用树状数组。\n如图，开一个数组$t$视为树状数组，$t_1$存的是$a_1$，$t_2$存的是$a_1+a_2$,$t_4$存的是$a_1+a_2+a_3+a_4$，$t_8$存的是$a_1+a_2+a_3+a_4+a_5+a_6+a_7+a_8$。别的也是如图一一对应的。\n这样存储会带来什么性质?\n我们把$t$存的数的区间称为管辖区间。这个管辖区间为$[i-lowbit(i)+1,i]$。长度为lowbit(i)。\n什么是lowbit(i)?\nlowbit(i)是i的二进制表示中最低位的1所代表的数值。\n例子:lowbit(1100100)=0000100\nlowbit公式:lowbit(i)=i\u0026amp;(-i)\n我们把这个公式代入到例子看，$t_8$长度就为8，它的管辖区间为$[8-lowbit(8)+1,8]=[1,8]$。因此他是$a_1+a_2+a_3+a_4+a_5+a_6+a_7+a_8$。\n那么我们如何进行单点修改呢?\n可以看出，如果我们对$a_3$进行修改，那么$t_3,t_4,t_8$都要进行修改。这样的影响是有规律的。\n我们可以发现,3+lowbit(3)=4,4+lowbit(4)=8，所以我们可以用一个循环来实现单点修改。\n那么接下来我们就要实现区间查询了。\n虽然$t_8$把全部元素包括了，但假如我们要的和是部分的话该怎么办呢？例如，我们要的是$a_1$到$a_7$的和。观察一下，可以发现$a_1$到$a_7$可以分为$t_4$+$t_6$+$t_7$。\n这种无缝连接的块也是有规律的。\n我们可以发现，7-lowbit(7)=6,6-lowbit(6)=4，所以我们可以用一个循环来实现区间查询。\n最后，如何初始化树状数组呢?\n我们可以把$t$数组初始化为0，然后用单点修改来实现初始化，就可以了。（和差分的思想有点类似）。\n例题1 P40 【模板】树状数组（单点修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; typedef long long ll; ll a[N], t[N]; int n, q; int lowbit(int x) { return x \u0026amp; -x; } void update(int k, ll x)//单点修改，也负责初始化 { for (int i = k; i \u0026lt;= n; i += lowbit(i)) { t[i] += x; } } ll getsum(int k)//区间查询求前缀和 { ll ans = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i)) { ans += t[i]; } return ans; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } // 初始化树状数组 for (int i = 1; i \u0026lt;= n; i++) { update(i, a[i]); } // 操作 for (int i = 1; i \u0026lt;= q; i++) { int x; cin \u0026gt;\u0026gt; x; if (x == 1) { int k; ll v; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; update(k, v); } else { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll ans = 0; ans = getsum(r) - getsum(l - 1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } return 0; } 接下来讲区间修改。\n如果是区间修改，离线的话我们可以用差分来实现，时间复杂度比树状数组更加优秀。\n但是，如果是要求在线的区间修改，即修改一次，就要我们出一次值，我们就必须用树状数组来实现了。\n树状数组想要实现区间修改，就是从维护普通的前缀和变成维护差分数组的前缀和。\n如图，我们得出推广公式:\n$$\\sum_{i=1}^{r}a_i=\\sum_{i=1}^{r} (r+1)d_i-\\sum_{i=1}^{r}id_i$$那么我们用两个树状数组来维护这两个差分前缀和就可以了。\n我们可以先初始化出差分数组$d$，然后用树状数组来维护$d$的前缀和。也可以直接就用树状数组来得出$d$的前缀和。\n例题2 P41 树状数组（区间修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; typedef long long ll; ll a[N], dt[N], dti[N]; int n, q; int lowbit(int x) { return x \u0026amp; -x; } void update(int k, ll x) //单点修改，一次对两个树状数组进行修改 { for (int i = k; i \u0026lt;= n; i += lowbit(i)) { dt[i] += x; dti[i] += k * x; //注意这里是k*x，不是i*x } } ll getsum(int k) //区间查询，运用刚才的公式得出 { ll ans = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i)) { ans += (k + 1) * dt[i] - dti[i]; } return ans; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } // 初始化树状数组 for (int i = 1; i \u0026lt;= n; i++) { update(i, a[i]); update(i + 1, -a[i]); //根据差分，我们这样单点修改就可以实现区间修改了 } // 操作 for (int i = 1; i \u0026lt;= q; i++) { int x; cin \u0026gt;\u0026gt; x; if (x == 1) { int l, r; ll v; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v; update(l, v); //区间修改 update(r + 1, -v); } else { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll ans = 0; ans = getsum(r) - getsum(l - 1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } return 0; } 附加题 P31 求逆序对个数\n题面:\n给定一个长度为$n$的数组$a$，求$a$的逆序对个数。\n逆序对的定义是一个二元组$(a_i,a_j)$,满足:$i\u0026lt;j$且$a_i\u0026gt;a_j$。\n输入格式:\n一个整数n.($1\\leq n\\leq 2\\times10^5$)\n一个长度为$n$的数组$a$。($1\\leq a_i\\leq 10^9$)\n输出格式:\n一个整数，表示逆序对的个数。\n分析：\n此题求解逆序对，可以使用权值数组来求解，权值数组其实就是一个桶，桶的下标就是数组的值，桶的元素就是数组的值的个数。\n如图，我们把2,3,1,1,6依次归入桶中，先进2，$a_2$值为1，然后遍历$a_2$之后的桶，发现桶里面个数都为0，说明2之前没有比2大的。然后进3，然后进1，发现有两个逆序对，再进1，发现有两个逆序对，如此结束。\n接着我们发现这样虽然找得到，但时间复杂度很高，而且(10^9)的范围太大，所以我们需要用离散化来优化。\n至于如何优化时间复杂度，可以这样逆向的求解，同样是2,3,1,1,6，2进桶之前，先判断下所有桶里面的元素个数，然后再减去其中比2小的元素个数，这样就可以得到2之前的逆序对个数。\n这样的话就要有个前缀和，我们可以用树状数组来实现（时间复杂度优秀，总共$O(nlogn)$）。并且建立在离散化处理的数组的基础上。\n树状数组\u0026lt;\u0026ndash;排名\u0026lt;\u0026ndash;值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; typedef long long ll; ll a[N], t[N]; vector\u0026lt;int\u0026gt; X; int getidx(int x) { return lower_bound(X.begin(), X.end(), x) - X.begin() + 1; } int lowbit(int x) { return x \u0026amp; -x; } int getsum(int k) { int res = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i)) { res += t[i]; } return res; } void update(int k, int x) { for (int i = k; i \u0026lt;= X.size(); i += lowbit(i)) { t[i] += x; } } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; X.push_back(a[i]); } // 排序去重 sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end()); /* 树状数组是建立在离散化数组上的 getsum(X.size())返回当前位置之前的所有元素的和 getsum(getidx(a[i]))返回当前位置之前小于等于a[i]的元素的个数 两者相减即为比 a[i] 大的元素的数量。 */ ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans += 1ll * getsum(X.size()) - getsum(getidx(a[i])); update(getidx(a[i]), 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } ","date":"2025-01-20T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/neuro_hu_beb9eea2665d8bfe.png","permalink":"https://baoziandbluemouse.github.io/p/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","title":"离散化，树状数组"},{"content":"前言 学习网站:Starrycoding\n单调栈 何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。\n将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。\n所以可以看出假如有元素要插入，这个元素一定是要插入进去的，但是假如插入进去后会破坏栈的单调性，那么就要先把栈顶的元素弹出，直到插入的元素不会破坏单调性为止。\n需要注意的是，这里的单调性是我们人为定义的，一般来说，我们往单调栈里插入的元素都是下标之类的东西，而不是值。所以这里的单调性是指一个我们定义的函数$f(x)$的单调性。\n接下来我们用一道例题来讲解一下单调栈该如何使用。\nP60 【模板】单调栈\n题面：给定一个长度为$n$的整数数组$a$，你需要求出每个元素的左边离它最近且比它小的元素。（如果不存在这样的元素，输出$-1$）\n单调栈的一个基本应用就是求左边离它最近且比它小的元素。（当然改一下方向也是可以的）\n分析：\n首先，根据样例,给出一个数组$a=[7,8,5,6,7]$。\n我们先想下如何暴力解决这个问题。\n我们可以设置一个数组$l$，用来存储每个元素的左边离它最近且比它小的元素。\n我们可以先把$l$数组的所有元素都初始化为$-1$。接下来再用一个二重的循环来寻找每个元素的左边离它最近且比它小的元素。如果找到了，就把$l[i]$的值设为$a[j]$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 9; int arr[N], l[N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } memset(l, -1, sizeof(l)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt;= 1 \u0026amp;\u0026amp; l[i] == -1; j--) { if (arr[j] \u0026lt; arr[i]) { l[i] = arr[j]; } } } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; l[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 当然，这样绝对会TLE，时间复杂度是$O(n^2)$的。\n那么我们就要想下如何优化了。\n我们再用个例子理解一下，给出一个数组$a=[6,7,8,1,5,4,3]$。\n6左边没有比它小的元素，所以输出$-1$。\n7左边比它小的元素是6，所以输出6。\n8左边比它小的元素是7，所以输出7。\n1左边没有比它小的元素，所以输出$-1$。\n接下来5，4，3输出的都是1.\n假设一下我们当前元素为i，通过观察我们可以发现，首先对于i要输出的元素的判断有两个条件，一个是距离，一个是大小。\n例子中，对于数字5，4，3而言，数字1和前面的6，7，8相比，不仅距离更优秀，大小也更优秀，所以我们完全可以无视6，7，8。只管数字1后面有没有在距离或者大小上更优秀的数字就可以了。\n既然如此，我们可以用单调栈来模拟这个过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 9; int arr[N], l[N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } stack\u0026lt;int\u0026gt; stk; // 栈内存放下标 for (int i = 1; i \u0026lt;= n; i++) { while (stk.size() \u0026amp;\u0026amp; arr[stk.top()] \u0026gt;= arr[i]) { stk.pop(); } if (stk.size()) { // 栈非空 l[i] = stk.top(); } else { // 栈空 l[i] = -1; } // 将当前元素下标push进去 stk.push(i); } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; (l[i] == -1 ? -1 : arr[l[i]]) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 stack\u0026lt;int\u0026gt; stk; // 栈内存放下标 for (int i = 1; i \u0026lt;= n; i++) { while (stk.size() \u0026amp;\u0026amp; arr[stk.top()] \u0026gt;= arr[i]) { stk.pop(); } if (stk.size()) { // 栈非空 l[i] = stk.top(); } else { // 栈空 l[i] = -1; } // 将当前元素下标push进去 stk.push(i); } 分析：\n我们用while函数确保栈顶元素始终要小于等于当前要插入的元素。（当前插入的元素在距离上更优秀，大小上不会）\n如果栈顶元素大于当前要插入的元素，那么就把栈顶元素弹出直到小于为止。（当前插入的元素在距离上更优秀，大小上也更优秀，就不需要栈顶元素了）\n接下来一个if函数来分类讨论，栈空时，就代表当前元素左边没有比它小的元素，则l[]为-1。栈非空时，栈顶元素就是距离最优还小于等于当前元素的元素，所以l[]为栈顶元素下标。\n最后我们把当前元素下标push进去。\n单调队列 顾名思义，单调队列的重点分为「单调」和「队列」。\n「单调」指的是元素的「规律」——递增（或递减）。（和单调栈一样，递增递减是最简单的单调性，我们传入单调队列的元素一般是下标，下标的单调性是无意义的，更要注意其相关函数的单调性）\n「队列」指的是元素只能从队头和队尾进行操作。\n单调队列和单调栈差不多，区别是单调队列的队头和队尾都可以进行操作。\n单调队列最经典的应用是滑动窗口。\n我们直接用一个例题来看看怎么用单调队列。\nP61 滑动窗口\n题面：\n给定一个长度为$n$的整数数组$a$，以及一个长度为$k$的滑动窗口。窗口中只能看到$k$个元素），它从数组的最左边，每次向右移动一个位置，直到移动到最右边。\n你需要回答出滑动窗口在每个位置时，窗口中的最大值和最小值。\n首先，我们可以用单调队列来模拟这个滑动窗口，然后分两次，一次求最大值，一次求最小值。\n我们要先求最大值，所以我们要维护一个单调递减的队列。那么我们就要保证队尾元素始终要大于等于当前要插入的元素。（这里由于区间的限制，我们队列内肯定是插入下标的，所以我们要比较的是下标对应的元素）\n接着，我们要保证单调队列的长度始终要小于等于$k$。那么就要确保队头元素始终要大于等于$i-k$。（$i$是当前要插入的元素的下标,$[i-k+1,i]$）\n然后，我们判断一下，如果要输出元素了，而当前队列为空，那么当前要插入的元素就是最优的，否则就是队头元素最优了。简化一下，其实就是push当前元素进队尾，然后输出队头元素。\n最终，我们可以得到如下流程:\n那么开始输出答案的时候就是i\u0026gt;=k的时候，从这个时候开始，每次循环都会输出一个最优秀的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; int a[N]; int main(void) { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } deque\u0026lt;int\u0026gt; dq; // 求最大 for (int i = 1; i \u0026lt;= n; i++) { // 以i为右端点，大小为k的区间，[i-k+1,i] // 队头合法性 while (dq.size() \u0026amp;\u0026amp; dq.front() \u0026lt;= i - k) { dq.pop_front(); } // 队尾优越性 while (dq.size() \u0026amp;\u0026amp; a[dq.back()] \u0026lt;= a[i]) { dq.pop_back(); } dq.push_back(i); if (i \u0026gt;= k) { cout \u0026lt;\u0026lt; a[dq.front()] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; dq = deque\u0026lt;int\u0026gt;(); // 清空 // 求最小 for (int i = 1; i \u0026lt;= n; i++) { // 以i为右端点，大小为k的区间，[i-k+1,i] // 队头合法性 while (dq.size() \u0026amp;\u0026amp; dq.front() \u0026lt;= i - k) { dq.pop_front(); } // 队尾优越性 while (dq.size() \u0026amp;\u0026amp; a[dq.back()] \u0026gt;= a[i]) { dq.pop_back(); } dq.push_back(i); if (i \u0026gt;= k) { cout \u0026lt;\u0026lt; a[dq.front()] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 附加题 P62 求和\n题面：\n给定一个大小为$n$的整数序列$a$（下标从$1$开始），你需要求出该序列所有子区间最小值的和，即\n$$\\sum_{i=1}^{n} \\sum_{j=i}^{n} min(a_i,a_{i+1},...,a_j)$$分析:\n这题要求出该序列所有子区间最小值，然后再将他们加起来。如果暴力做的话，就是用循环找出每个子区间，然后再找出每个子区间的最小值，然后再将他们加起来。但是这样做的话，时间复杂度是$O(n^2)$的，会TLE。\n那么该如何优化呢？\n这题算是一种数字贡献的题目。\n如图，我们可以看出，给定数组$a=[7,8,5,6,7]$，对于数字$5$，有好几个子区间包含它,我们可以把它看成是一个贡献。那么有几个子区间包含它，它就会贡献几次。那我们要如何计算出有几个子区间包含它呢？我们可以看它的管辖区间，就是看他左边有几个比它大的数字，右边有几个比它大的数字，然后将这两个个数相乘，就是他包含的子区间个数了。注意5自己也是算的。并且假如碰到了小于它的数字，就要停止。\n那么我们来看对于5，他左边有7，8，5大于等于他，右边有，5，6，7大于等于他，所以它包含的子区间个数是3*3=9个。这9个子区间最小值都是5，5贡献了9次。同理我们可以得到其他数字的贡献次数。如此我们就可以得出答案了。\n那么我们要如何实现找出每个数字的管辖区间呢？\n我们给定一个数组$a=[1,3,2,5,2,7,2]$，这里我们还能发现按刚才做法找管辖区间会发现相等的情况，那么我们要如何处理呢？\n我们可以直接定义好规则:\n我们用一个数组$l[i]$来表示数字$a[i]$左边有几个大于等于它的数字,用一个数组$r[i]$来表示数字$a[i]$右边有几个比它大（严格大于）的数字。那么假如遇到了相等的情况，就不可能错误了。\n但是这样的l和r数组的存储也会有些麻烦,我们可以改为存储下标。\nl[i]表示数字$a[i]$左边最近的小于它的数字的下标。 r[i]表示数字$a[i]$右边最近的小于等于它的数字的下标。 然后要求出左边有几个，就是($i-l[i]$)个。右边有几个，就是($r[i]-i$)个。\n那么这种l和r该如何求呢？显而易见是单调栈。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 9; ll a[N], l[N], r[N]; ll stk[N], top; int main(void) { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } // 求l[],l[]是i左边最近的\u0026lt;a[i]的值的位置 for (int i = 1; i \u0026lt;= n; i++) { while (top \u0026amp;\u0026amp; a[stk[top]] \u0026gt;= a[i]) { top--; } // 判断 if (!top) { l[i] = 0; // i左边没有任何数比a[i]还小了,能够一直延申 } else { l[i] = stk[top]; } // 存放 stk[++top] = i; } // 初始化 top = 0; // 求r[],r[]是i右边最近的\u0026lt;=a[i]的值的距离 for (int i = n; i \u0026gt;= 1; i--) { while (top \u0026amp;\u0026amp; a[stk[top]] \u0026gt; a[i]) { top--; } // 判断 if (!top) { r[i] = n + 1; // i右边没有数小于等于i，可以一直延申 } else { r[i] = stk[top]; } // 存放 stk[++top] = i; } // l[i]和r[i]都是开区间 ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans += a[i] * (r[i] - i) * (i - l[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2025-01-16T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E5%8D%95%E8%B0%83%E6%A0%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/zhenhong_hu_c3f03564441a74c3.jpg","permalink":"https://baoziandbluemouse.github.io/p/%E5%8D%95%E8%B0%83%E6%A0%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","title":"单调栈，单调队列"},{"content":"前言 学习网站:Starrycoding\n本篇文章涉及部分STL的使用\n关于使用STL:【C++】算法竞赛常用 STL 用法\n栈 栈是一种先进后出的数据结构。\n栈的操作都是只管栈顶的。\n作用 用法 示例 构造 stack\u0026lt;类型\u0026gt; stk stack\u0026lt;int\u0026gt; stk; 进栈 .push(元素) stk.push(1); 出栈 .pop() stk.pop(); 取栈顶 .top() int a = stk.top(); 判空 .empty() if(stk.empty()) 取栈大小 .size() int n = stk.size(); 栈没有clear操作。\n例题 P38 火车轨道\n分析:\n火车按照顺序进入火车站,火车站是先进去的车最后出来的,所以我们可以用栈来模拟火车的进出。\n要使出栈口是升序的，也就是说要让出站口以$1,2,3\u0026hellip;.$的顺序排列。我们可以用一个变量来记录当前出站口的火车编号，然后每次判断栈顶的火车编号是否和当前出站口的火车编号相同，如果相同就出栈，否则就入栈,而且这个判断应该是重复的。\n最终当所有编号都判断完了之后，如果栈为空，就说明出站口的火车编号是$1,2,3\u0026hellip;.$的升序排列，否则就说明出站口的火车编号不是升序排列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5 + 9; int arr[N]; stack\u0026lt;int\u0026gt; stk; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } int cnt = 1; for (int i = 1; i \u0026lt;= n; i++) { stk.push(arr[i]); while (stk.size() \u0026amp;\u0026amp; stk.top() == cnt) { stk.pop(); cnt++; } } if (stk.size()) { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 注意：对栈顶进行操作时可能会有空栈的情况，所以要先判断栈是否为空。\n优先队列 优先队列是用堆实现的。 优先队列的所有操作都是针对堆顶的。 优先队列会确保堆顶的元素是最大/最小的。(通过比较器更改最大最小，默认是最大)\n作用 用法 示例 构造 priority_queue\u0026lt;类型,容器,比较器\u0026gt; pq 略 进队 .push(元素) pq.push(1); 出队 .pop() pq.pop(); 取队顶 .top() int a = pq.top(); 判空 .empty() if(pq.empty()) 取队列大小 .size() int n = pq.size(); 例题 P58 小e的菜篮子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main(void) { ios::sync_with_stdio(0); cout.tie(0); cin.tie(0); int q; ll sum = 0; priority_queue\u0026lt;ll\u0026gt; pq; // 默认是大根堆 cin \u0026gt;\u0026gt; q; while (q--) { int n; cin \u0026gt;\u0026gt; n; if (n == 1) { ll x; cin \u0026gt;\u0026gt; x; pq.push(x); sum += x; } if (n == 2) { if (pq.size()) { sum -= pq.top(); pq.pop(); } } } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } map map是由红黑树实现的。可以理解为一堆有序（默认从小到大）的键值对。\nmap还具有互异性，即键(key)不能重复。\n作用 用法 示例 构造 map\u0026lt;键类型,值类型，比较器\u0026gt; mp 略 插入 .insert({键,值}) mp.insert({1,1}); 删除 .erase(键) mp.erase(1); 查找（返回迭代器） .find(键) if(mp.find(1)!=mp.end()) 取键值 [键] int a = mp[1]; 判断元素是否存在 .count(键) if(mp.count(1)) 例题 P59 气球数量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 110; void solve() { map\u0026lt;string, int\u0026gt; mp; int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;string\u0026gt; v; for (int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s; if (mp.count(s)) { mp[s]++; } else { v.push_back(s); mp[s] = 1; } } for (auto \u0026amp;i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mp[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } set set也是由红黑树实现的。但他和map不同的是，set只存储value。\nset最重要的特性是互异性，即值(value)不能重复。\nset还具有有序性，即值(value)是从小到大排序的（默认，用比较器更改）。\n作用 用法 示例 构造 set\u0026lt;值类型,比较器\u0026gt; st 略 插入 .insert(值) st.insert(1); 删除 .erase(值) st.erase(1); 查找（返回迭代器） .find(值) if(st.find(1)!=st.end()) 判断元素是否存在 .count(值) if(st.count(1)) 注：\nset不能用下标访问。 set的迭代器是只读的。这意味着你不能通过迭代器来修改set中的值。只能先删除，再插入。 例题 P54 【模板】排序（1）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; set\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; st.insert(x); } for (auto \u0026amp;i : st) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } bitset 为了介绍bitset，我们先引入一道例题。\nP39 数的种类\n题目:给定$n$个整数，问由这些整数通过“加法”操作，可以组成多少种数字？\n分析:\n我们根据样例来看，样例给出1 1 5,答案有0,1,2,5,6,7六种数字，说明可以不选数字,得出来就是0.并且，这种加法操作有点涉及动态规划。\n这题可以算是一种存在性dp,对于dp的设计思路，要先从方便理解的高维开始，再逐渐优化。\n我们先设$dp[i][j]$表示前$i$个数，是否可以组成数字$j$,如果可以，就为1，否则为0。\n由图，我们可以看出，$dp[i][j]$可以由$dp[i-1][j]$和$dp[i-1][j-a[i]]$转移过来。\n那我们就可以先写出一套二维dp的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 typedef long long ll; bool dp[N][N]; void solve() { int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++) { cin\u0026gt;\u0026gt;a[i]; } dp[0][0]=1; for(int i=1;i\u0026lt;=n;i++) { //复制 for(j=0;j\u0026lt;=5e3;j++) { dp[i][j]=dp[i-1][j]; } //转移 for(int j=a[i];j\u0026lt;=5e3;j++) { dp[i][j]|=dp[i-1][j-a[i]]; } } ll ans =0; for(int i=0;i\u0026lt;=5e3;i++) { if(dp[n][i]) { ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } 但是，毫无疑问，这样做会导致TLE,我们要把二维设法优化成一维。 观察上述二维dp，我们可以发现其实只需要一维的$dp[j]$进行数次覆盖即可。\n最终我们得出完整代码.需要注意的是，这里$j$要从大到小枚举，因为如果从小到大枚举，就会导致$dp[j]$会不断true，导致答案错误。\n不过这样做还是会TLE，题目真正想要我们使用的是用bitset来做。\n我们可以把bitset理解为一个二进制数，我们可以用下标来访问二进制数的某一位。\n另外还有count()函数可以统计bitset中1的个数。reset()函数可以把bitset中的所有位都重置为0。\nbitset的好处: 他的所有操作都是$O(n/w)$的，其中$w$是bitset的位数。(这能极大地减少时间复杂度).\n同时，在用了bitset后，我们的转移方程也可以进行优化。\n我们可以看出dp[j-a[i]]实际上可以是原来的状态所有位移$a[i]$位，然后再和原来的状态进行或运算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 5e5 + 9; int a[N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; bitset\u0026lt;N\u0026gt; bs; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } bs[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { bs |= (bs \u0026lt;\u0026lt; a[i]); } cout \u0026lt;\u0026lt; bs.count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } P51 二进制中1的个数\n这道之前讲过的题也可以用bitset轻松解决。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 10; typedef long long ll; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, x; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; bitset\u0026lt;32\u0026gt;(x).count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 附加题 题面:\n给定两个长度为$n$的数组$a,b$,你现在可以给b重新排序。\n求下列表达式的最小值和最大值，两个询问相互独立。\n$$\\sum_{i=1}^{n} a_i\\times b_i$$输入格式：\n第一行一个整数$n$。($1\\leq n\\leq 2\\times10^5$)\n接下来一行$n$个整数表示$a_i$。($1\\leq a_i\\leq 10^5$)\n接下来一行$n$个整数表示$b_i$。($1\\leq b_i\\leq 10^5$)\n输出格式：\n一行两个整数，分别表示最小值和最大值。\n分析：\n这题首先要知道一个贪心性质：\n当两个数组的排序是同序时（即都从小到大或都从大到小），乘积之和最大。\n当两个数组的排序是逆序时（即最大的数字对最小的数字），乘积之和最小。\n我们可以这样理解，由于表达式是相乘的，我们把其中一个数组的数字算作是权重\n假设$a_i=1,2,3,4,5$,$b_i=5,4,3,2,1$，把b的数字当作权重\n那么假如我们想要让乘积之和最大，我们就应该让$a_i$的最大的数字权重尽可能高，让$a_i$的最小的数字权重尽可能低。也就是要同序。\n而假如我们想要让乘积之和最小，我们就应该让$a_i$的最小的数字权重尽可能高，让$a_i$的最大的数字权重尽可能低。也就是要逆序。\n知道了这个性质，同时我们还知道题目对b的排序是没有要求的，我们把b的数字中最大的都对到a的数字中最大的，最小的都对到a的数字中最小的，这样就可以保证乘积之和有最大和。\n要这么实现就直接对两个数组排序，然后相乘即可。同理也可以得出最小和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 9; ll a[N], b[N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; b[i]; } sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); ll ansMAX = 0, ansMIN = 0; for (int i = 1; i \u0026lt;= n; i++) { ansMAX += a[i] * b[i]; } reverse(b + 1, b + n + 1); // 反转 for (int i = 1; i \u0026lt;= n; i++) { ansMIN += a[i] * b[i]; } cout \u0026lt;\u0026lt; ansMAX \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ansMIN \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2025-01-14T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E6%A0%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97mapsetbitset/mountain_hu_d2fb43d25a91bc90.jpg","permalink":"https://baoziandbluemouse.github.io/p/%E6%A0%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97mapsetbitset/","title":"栈，优先队列，map，set，bitset"},{"content":"前言 学习网站:Starrycoding\n本篇文章涉及位运算，排序，双指针，二分.\n位运算 如图，位运算有这几种操作,比较常出现的是异或和与。\n与的应用：作为掩码来使用。 如000111 \u0026amp; 000001= 000001，这样就可以取出最后一位。\n异或的性质:\n注：因为异或满足结合律，所以异或运算可以进行类似前缀和的预处理\n例题 P51 二进制中1的个数\n分析：朴素算法就是把数字转成二进制，然后统计1的个数，实现的话我们就可以用掩码来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 10; typedef long long ll; ll f(int x) { ll res = 0; while (x \u0026gt; 0) { if (x \u0026amp; 1 == 1) res++; x \u0026gt;\u0026gt;= 1; } return res; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, x; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; f(x) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } P52 我们需要0\n分析： 这题定义了$b_i=a_i⊕x$，并且要使得$b_1⊕b_2⊕\u0026hellip;⊕b_n=0$ 那么我们把$b_1⊕b_2⊕\u0026hellip;⊕b_n$拆开，那么就可以转化成$a_1⊕a_2⊕\u0026hellip;⊕a_n⊕x⊕x⊕\u0026hellip;⊕x=0$ （运用了交换律） 这里再运用异或的性质，即$x⊕x=0$，那么就可以转化成\n$$a_1⊕a_2⊕...⊕a_n⊕x=0$$$$a_1⊕a_2⊕...⊕a_n⊕x=x⊕x$$$$a_1⊕a_2⊕...⊕a_n⊕x⊕x=x⊕x⊕x$$$$a_1⊕a_2⊕...⊕a_n=x$$所以我们就能得到x了，也知道x是必定存在且唯一的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;bits/stdc++.h\u0026gt; //运用异或性质+结合律,a^b^c=a^(b^c)+交换律,a^b^a=a^a^b=0^b=b using namespace std; // 异或性质：a^a=0,a^0=a const int N = 1e3 + 10; typedef long long ll; ll arr[N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t, n; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } int res = 0; for (int i = 1; i \u0026lt;= n; i++) { res ^= arr[i]; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } P53 Mex and Xor\n分析: 根据题目定义 MEX值是指：最小的不存在于该数组之中的非负整数。 例：$a=[0,3,2,2]$,则$MEX(a)=1$。\nXOR值是指：数组中的所有元素做异或运算的结果。 例:$a=[3,5,5]$,则$XOR(a)=3⊕5⊕5=3$。\n给定了MEX值与XOR值，我们要求出满足这两值的非负整数数组的最小长度。因为长度最小，可以认为arr数组必须具有有序性，以及互异性.\n假设MEX值为a，XOR值为b,假设有序数组为$arr=[0,1,2,3,4,5\u0026hellip;a-1,a+1,a+2,a+3\u0026hellip;]$\n我们可以发现arr被分成了两部分，一部分是$[0,a-1]$，将这部分设为$x$,因为我们的arr要保证最小长度，所以这部分值是确定的,另一部分是$[a+1\u0026hellip;.]$，将这部分设为$y$\n则有\n①.$x⊕y=b$\n②.$y=x⊕b$\n根据y的值不同我们就可以得到不同的数组长度结果，所以接下来我们开始分类讨论\n1.y=0时，那么就说明x=b，此时数组长度就为a\n2.y=a时，因为我们不能有a，所以要把a拆成两个数（不难发现，一个数字a必定能拆成两个数的异或）,所以此时数组长度就为a+2\n3.y!=a且y!=0时，此时数组长度就为a+1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; //异或运算，异或前缀和 using namespace std; const int N = 2e5 + 9; int prexor[N]; void solve() { int len = 0; int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int y = prexor[a - 1] ^ b; if (y == 0) { len = a; } else if (y == a) { len = a + 2; } else { len = a + 1; } cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= 2e5; i++) { prexor[i] = prexor[i - 1] ^ i; } while (t--) { solve(); } return 0; } 注：此处[1,a-1]的值要用异或前缀和来预处理。\n排序 模板一\n通过排序去重（类似set）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; //运用排序，动态数组，unique实现去重 using namespace std; // 另一种去重办法使用set vector\u0026lt;int\u0026gt; a; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; a.push_back(x); } sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); // unique函数实际是把重复的数移到后面去了 // 最终函数会返回不重复的数的最后一个位置的后一个位置(迭代器),然后我们再用erase函数删除后面的数即可 // unique函数只能把相邻的重复数删除，所以我们需要先排序 // unique返回的是迭代器 for (auto \u0026amp;i : a) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 模板二\n使用了比较器的排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; struct book { int a, b, c; } p[N]; bool cmp(struct book a, struct book b) // 自定义比较器 以降序为例，如果你要降序，那么a\u0026gt;b就要返回true,否则返回false { if (a.a != b.a) { return a.a \u0026gt; b.a; } if (a.b != b.b) { return a.b \u0026gt; b.b; } return a.c \u0026gt; b.c; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; p[i].a \u0026gt;\u0026gt; p[i].b \u0026gt;\u0026gt; p[i].c; } sort(p + 1, p + n + 1, cmp); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; p[i].a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p[i].b \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p[i].c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们要定义的该比较操作为$⋆$\n若$a⋆b$，则比较器函数应当返回true\n若$a!⋆b$，则比较器函数应当返回false\n模板三\n桶排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 3e6 + 10; int arr[N]; int main(void) { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; arr[x]++; } for (int i = 0; i \u0026lt;= 2e5; i++) { for (int j = 0; j \u0026lt; arr[i]; j++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 双指针 如图，我们可以看到双指针的核心就是i,j的移动,我们以具体题目来解释\nP36 最长连续不重复子序列\n分析： 根据题目，我们要找出数组中最长的无重复的子序列,用双指针来实现\n由图，我们区间内维护的是无重复子序列的长度，那么我们j的移动条件就是区间内无重复，i的移动条件就是区间内有重复，并且每当我们的j+1是重复时，就可以对ans进行max判断.\n如何判断区间内有重复呢？我们可以使用桶来实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5 + 9; typedef long long ll; int arr[N], c[N]; void solve(void) { int n; ll maxx = -1; cin \u0026gt;\u0026gt; n; memset(arr, 0, sizeof(int) * n + 1); // 初始化数组 for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } for (int i = 1; i \u0026lt;= n; i++) { c[arr[i]] = 0; // 初始化桶 } for (int i = 1, j = 0; i \u0026lt;= n; i++) { while (j \u0026lt; n \u0026amp;\u0026amp; !c[arr[j + 1]]) { j++; c[arr[j]]++; } maxx = max(maxx, j - i + 1ll); c[arr[i]]--; } cout \u0026lt;\u0026lt; maxx \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } 二分 二分讲解\n模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; typedef long long ll; int arr[N]; int n, q, x; bool check(ll mid) { return arr[mid] \u0026lt; x; } void solve(void) { cin \u0026gt;\u0026gt; x; ll l = 0, r = n + 1, mid = 0; while (l + 1 != r) { mid = (l + r) / 2; if (check(mid)) { l = mid; } else { r = mid; } } if (arr[r] == x) { cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } while (q--) { solve(); } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 使用条件：答案具有单调性\n关键词: 最大最小值，最小最大值\n求最小要找答案的下界，求最大要找答案的上界\n以l，r作为两个指针来理解\n建模：确立蓝红区域（分界线） 确定check（）函数（根据分界线来写 分界线左边的数字都有什么性质，右边又有什么性质） 确定返回r还是l 套用模板 二分一次只能出一个答案（r或l） l，r初始值是开区间的左右端点,以数组下标0开头的话，l=-1，r=N（如果l，r代表数字的话，就是答案数据范围的左右端点） 例题 P37 进击的奶牛\n分析： 最近距离就是指相邻的两头牛的距离，这个距离越大越好\n也就是说我们假设所有相邻距离集合为A，最大的相邻距离为max,那么A必须满足\n任选A中一个元素，都大于等于max,则此max为最小最大值 (所有种的A中的最小元素的集合中的最大值)\n对样例分析，我们可以得出二分分界线：给定最小相邻距离，能否放下要求放的牛数量\n由图，我们知道了最小相邻距离与能放下的牛数量的关系，那么我们就可以用二分来实现了。并且，由于left左端是$(max)_c\u0026gt;=x$的,left会不断右移直到下一个值不会大于等于x,所以left会是最小最大值。\n（同理，我们能知道假如right是$(max)_c\u0026lt;=x$的话，right会不断左移直到right左边的值大于x,最终会得到$r=1$,并非所求值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 9; int n, c; int arr[N]; bool check(ll mid) { int j = 1; int cnt = 1; // 注意这里牛已经在第一个位置放了一头了 for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] - arr[j] \u0026gt;= mid) { cnt++; j = i; } } return cnt \u0026gt;= c; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } sort(arr + 1, arr + n + 1); ll l = 0, r = 1e9 + 10, mid = 0; while (l + 1 != r) { mid = (l + r) / 2; if (check(mid)) { l = mid; } else { r = mid; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2025-01-11T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88%E4%BA%8C%E5%88%86/zhenhong_hu_349f3e99b7f1461d.jpg","permalink":"https://baoziandbluemouse.github.io/p/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88%E4%BA%8C%E5%88%86/","title":"位运算，排序，双指针，二分"},{"content":"前言 学习网站:Starrycoding\n前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。\n前缀和 前缀和预处理可以帮助我们在$O(1)$的时间复杂度内求出$a$数组中任意区间$[l,r]$的和，即$a_l+a_{l+1}+a_{l+2}+\u0026hellip;+a_r$，而不需要每次都遍历一遍区间，这大大提高了查询的效率。\n前缀和通常用数组来实现,假设我们有一个数组a，那么我们可以用数组b来表示a的前缀和，即\n$$b_1=a_1,b_2=a_1+a_2,b_3=a_1+a_2+a_3....$$如此循环，直到加到$b_n$，那么$b_n$就是a的所有元素之和 一维前缀和题目:P7 【模板】前缀和\n模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t, n, q; cin \u0026gt;\u0026gt; t; while (t--) { vector\u0026lt;ll\u0026gt; arr(100010); vector\u0026lt;ll\u0026gt; sum(100010); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } sum[1] = arr[1]; for (int i = 2; i \u0026lt;= n; i++) { sum[i] = sum[i - 1] + arr[i]; // 前缀和处理 } int l = 0, r = 0; while (q--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll res = sum[r] - sum[l - 1]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } return 0; } 补充：二维前缀和 二维前缀和思想和一维的一致，只不过我们需要二维数组来实现，并且初始化也会有所不同\n二维前缀和题目:P15 【模板】二维前缀和\n如图即为二维前缀和的初始化（少加了$a_{3,3}$），我们假设一个二维数组a，我们用二维数组b来表示a的二维前缀和，即\n$$b_{3,3}=b_{2,3}+b_{3,2}-b_{2,2}+a_{3,3}$$这涉及了一点递归（递推）的思想（可以自己从1，1开始推一下）\n模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1200; int g[N][N]; ll prefix[N][N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; g[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + g[i][j]; } } int x_l, y_l, x_r, y_r; while (q--) { cin \u0026gt;\u0026gt; x_l \u0026gt;\u0026gt; y_l \u0026gt;\u0026gt; x_r \u0026gt;\u0026gt; y_r; ll res = 0; res = prefix[x_r][y_r] + prefix[x_l - 1][y_l - 1] - prefix[x_r][y_l - 1] - prefix[x_l - 1][y_r]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 差分 差分的作用是在$O(n)$ (n为修改数值次数)的时间复杂度内，将$a$数组中$[l,r]$区间的所有数加上一个数$c$，而不需要每次都遍历一遍区间，这同样也是一种预处理从而增加效率的方式。 需要注意的是通过差分实现区间修改，是一种静态维护,也就是说我们只能在修改完才能询问，而无法边修改边询问。\n假设我们有一个数组a，用数组b来表示a的差分，即\n$$b_1=a_1,b_2=a_2-a_1,b_3=a_3-a_2....$$这里我们可以发现一个规律，如果得出b数组的前缀和,那么就有\n$$b_1+b_2+...b_i=a_1+a_2-a_1+...a_i-a_{i-1}$$ 即\n$$b_1+b_2+...b_i=a_i$$我们由此得出差分的性质就是可以通过差分的前缀和来得到原数组的其中一个元素。 基于差分的这个性质，我们就可以用差分来实现静态的区间修改 如果我们给差分数组d中的$d_2$加上一个数$x$,那么用前缀和还原时，就会发现从$a_2$开始所有的数都加上了$x$ 那假如我们要给$[2,3]$区间加上一个数$x$呢？\n$$d_l+=x,d_{r+1}-=x$$此时，我们再回过头看开头时我们是如何表示差分的,就可以发现其实他们也遵循了这个修改区间的公式,只不过他们的区间很小,是$[1,2]$,$[2,3]$,$[3,4]$\u0026hellip;以此类推下去。 注:一维差分数组可以直接用$d_i=a_i-a_{i-1}$来表示，而二维差分数组我们一般用上面的公式来初始化\n一般来说，差分题目在修改完区间后，就会询问区间和，所以还会需要再进行一次前缀和\n一维差分题目:P8 【模板】差分\n模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 9; ll arr[N]; ll differ[N]; ll prefix[N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, p, q; ll x = 0, l = 0, r = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } for (int i = 1; i \u0026lt;= n; i++) { differ[i] = arr[i] - arr[i - 1]; // 差分处理 } while (p--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; differ[l] += x; differ[r + 1] -= x; // 修改区间 } for (int i = 1; i \u0026lt;= n; i++) { arr[i] = arr[i - 1] + differ[i]; // 通过差分还原数组，并且数据经过修改 } for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + arr[i]; // 前缀和 } while (q--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll res = 0; res = prefix[r] - prefix[l - 1]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 补充：二维差分 二维差分的特点就如前面所说，我们初始化需要使用公式才会更有助于理解\n二维差分题目:P50 【模板】二维差分\n由图，我们先假设我们已经初始化了一个二维差分数组，图上这些格子内部便是坐标点,现在我们要给$[2,2]$到$[4,4]$区间加上一个数$x$ 就应该把$d_{2,2}$加上$x$，$d_{4+1,2}-=x$,$d_{2,4+1}-=x$,$d_{4+1,4+1}+=x$\n同理，我们初始化也可以如此操作\n$$d_{x_1,y_1}+=x,d_{x_2+1,y_1}-=x,d_{x_1,y_2+1}-=x,d_{x_2+1,y_2+1}+=x$$模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1100; int arr[N][N]; int differ[N][N]; int prefix[N][N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; arr[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { differ[i][j] += arr[i][j]; // 这里差分初始化用的原理和下面一样 differ[i + 1][j] -= arr[i][j]; // 和下面不一样的是因为就只要一个格子变，所以左上右下的坐标都是(i,j) differ[i][j + 1] -= arr[i][j]; differ[i + 1][j + 1] += arr[i][j]; } } int a, b, c, d, v; while (q--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; v; differ[a][b] += v; differ[a][d + 1] -= v; differ[c + 1][b] -= v; differ[c + 1][d + 1] += v; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { arr[i][j] = arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1] + differ[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 附加题 涉及:?运算符的应用,最大子段和\n题目p35.鼠鼠我鸭\n分析：题目将重量分为两种类型，一种可以算进答案，一种不行，并且，我们可以使用一次操作来变更一段区间$[l,r]$的类型，我们可以用一个bool数组来记录，0代表不行，1代表可以,既然要求最大值，那么我们可以先把未改变时的答案求出来,接着再求更改时的增加量。\n如图，想要实现这个功能可以运用？运算符(不过此题也可以直接乘以bool数组来实现)\n接着，观察题目不难发现，更改后的答案绝对是要\u0026gt;=未改变时的答案的，所以我们只需要比较更改后的增加量和0的大小即可。 此时要求出这个增加量，我们可以先初始化一个全变更的数组（偏移量数组），接着在这个数组中求出最大子段和即可。\n这里有两种求最大子段和的方法:\n前缀和求法 我们将偏移量数组求前缀和，然后用$prefix_r-prefix_{l-1}$来求出最大子段和（要使fix最大，就要使$prefix_{l-1}$在区间$[0,r-1]$为确定的最小值,然后再枚举$prefix_r$即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 ll minn = 0; // minn默认为0是因为prefix[]中的元素从1开始，而我们要找prefix[l-1]的最小值是可以超出下标的， // 所以绝对会找到prefix[0]，则minn可以取0 for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + a[i] * (w[i] ? -1 : 1); } ll fix = 0; for (int i = 1; i \u0026lt;= n; i++) // 求偏移量的最大字段和方法(使用前缀和) { fix = max(fix, prefix[i] - minn); minn = min(minn, prefix[i]); } 贪心求法 如果mx\u0026lt;0,则将其重置为0,然后再加上a[i]即可,最后再用mx更新答案即可。 思想：如果当前的字段和为负数，那么下一次加数字时，我们选择重置为0再加绝对会比直接加的数字大\n1 2 3 4 5 ll mx = 0; for (int i = 1; i \u0026lt;= n; i++) { mx = max(0ll, mx + a[i] * (w[i] ? -1 : 1)); } 题目答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 9; ll a[N]; bool w[N]; ll prefix[N]; int n; int main(void) { ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } ll sum = 0; ll ess = 0; ll minn = 0; // minn默认为0是因为prefix[]中的元素从1开始，而我们要找prefix[l-1]的最小值是可以超出下标的， // 所以绝对会找到prefix[0]，则minn可以取0 for (int i = 1; i \u0026lt;= n; i++) { ess += a[i] * w[i]; } for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + a[i] * (w[i] ? -1 : 1); } ll fix = 0; for (int i = 1; i \u0026lt;= n; i++) // 求偏移量的最大字段和方法(使用前缀和) { fix = max(fix, prefix[i] - minn); minn = min(minn, prefix[i]); } ll ans = ess + fix; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","date":"2025-01-01T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/mu_hu_ca58fb10b2054e6a.jpg","permalink":"https://baoziandbluemouse.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","title":"算法学习-前缀和与差分"},{"content":"学习视频链接:C++输入输出提速底层分析｜缓冲区｜同步流取消\n为何cpp输入输出会变慢（和C相比） iostream i/o 与 stdio i/o 保持同步带来的耗时（取消同步流） cin 与 cout 存在绑定耗费时间 endl相比\\n 耗时 上述三个原因对于c来说都是没有的，因此在cpp中使用c风格的输入输出可以极大的提速。 但是c风格的输入输出更适合格式化输出，没有cin和cout的便捷，因此想要同时拥有便捷和速度的话就要解决这三个问题\n取消同步流 什么是同步流？ 同步指的是c输出输入与cpp输出输入保持同步，由于cpp为了兼容c，c输出输入与cpp输出输入使用的是同一块缓冲区，我们将其称为c流缓冲区 如图所示，这个同步操作带来了耗时，我们可以通过以下代码取消同步流\n1 ios::sync_with_stdio(false); 取消cin与cout绑定 什么是cin与cout绑定？ 这是使输入输出更加安全的一个操作，绑定指的是每次cin输入前都会刷新cout缓冲区\n解除绑定操作如下\n1 2 cin.tie(0); cout.tie(0); 值得注意的是，cout.tie(0)这个语句似乎是多余的，因为cout本来就与null绑定了,不过由于大家都这么写，所以还是写上\n用\u0026rsquo;\\n\u0026rsquo;代替endl 为何endl会比\u0026rsquo;\\n\u0026rsquo;慢？ 实际上endl=\u0026rsquo;\\n\u0026rsquo; + 强制刷新缓冲区 也就是说\n1 cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;flush; 与\n1 cout\u0026lt;\u0026lt;endl; 是一样的，所以就是这个多出来的强制刷新缓冲区导致的耗时 \u0026lsquo;\\n\u0026rsquo;本身是不会刷新缓冲区的，他会在下一行代码执行时刷新缓冲区 endl本身是会刷新缓冲区的，并且，在下一行代码执行时他还会再次刷新 也就是说，endl会比\u0026rsquo;\\n\u0026rsquo;多刷新一次缓冲区，所以会慢一些\n其实这也是一种安全性的措施，endl保证了在程序崩溃时，能完成输出，而\u0026rsquo;\\n\u0026rsquo;则不能\n总结 使cpp风格输入输出提速的解决方法就是\n取消同步流 取消cin与cout绑定 用\u0026rsquo;\\n\u0026rsquo;代替endl 1 2 3 4 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cout\u0026lt;\u0026lt;something\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; ","date":"2024-12-28T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/cpp%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8F%90%E9%80%9F%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/card-normal_hu_3fb8929bf8106e4.jpg","permalink":"https://baoziandbluemouse.github.io/p/cpp%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8F%90%E9%80%9F%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/","title":"cpp输入输出提速底层分析"},{"content":"搜索专题 搜索算法，包括深度优先搜索和广度优先搜索，从起点开始，逐渐扩大寻找范围，直到找到需要的答案为止。\n严格来说，搜索算法也算是一种暴力枚举策略，但是其算法特性决定了效率比直接的枚举所有答案要高，因为搜索可以跳过一些无效状态，降低问题规模。在算法竞赛中，如果选手无法找到一种高效求解的方法（比如贪心、递推、动态规划、公式推导等），使用搜索也可以解决一些规模较小的情况；而有的任务就是必须使用搜索来完成，因此这是相当重要的策略。\n学习视频链接:DFS正确入门方式 | DFS + 递归与递推习题课(上) | 一节课教你爆搜!\n深度优先搜索 深度优先搜索的特性： 搜索过程中会沿着一条路径一直走到底，直到不能走为止，然后退回到上一个节点，继续搜索。 搜索使用到的数据结构是栈，可以使用递归实现，草稿时可以画出一个树状结构来辅助理解。 根据树状结构图，我们可以得出搜索的两个基本点，一个是位置有多少，一个是每个位置上有多少中选择 空间复杂度大概就是o(h),h为树高 深度优先搜索具有三种基本形式： 指数级枚举 对于一个位置，有若干种选择，他能选择其中的任何一种，接着下一个位置同样能选择其中的任何一种，不会因为已选择位置的增加而使方案选择变少，若有n个位置，每个位置有m种选择，则总方案数为m^n。时间复杂度大概就是o（m^n）。 题型 迷宫问题和洪水填充模型，但这类问题得数据量很小才能用dfs，更好的方法是用bfs。 一些简单的指数级枚举递归题目，比如P2036 PERKET|P2089 烤鸡 指数级枚举的代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void dfs(int x)//x表示当前位置,一般从1开始 { if(x\u0026gt;n) //n代表位置的总数 { //根据题目做一些操作 return; } for(int i=1;i\u0026lt;=m;i++)//m代表每个位置能选择m种方案 { arr[x]=1; //一般会开个数组代表当前位置的选择,1代表选择，0代表未考虑 dfs(x+1); arr[x]=0; //代表恢复 } //如果题目只有两种选择，选或者不选，也可以不用for //选 arr[x]=1; dfs(x+1); arr[x]=0; //不选 arr[x]=2; dfs(x+1); arr[x]=0; } 以P2036 PERKET为例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct pos { int bitter; int sour; }; struct pos a[20]; int st[20]; int n; int minn = 1e9; void dfs(int x); int main(void) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i].sour \u0026gt;\u0026gt; a[i].bitter; } dfs(1); cout \u0026lt;\u0026lt; minn \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } void dfs(int x) { if (x \u0026gt; n) { bool flag = false; int sum = 0; int mut = 1; for (int i = 1; i \u0026lt;= n; i++) { if (st[i] == 1) { sum += a[i].bitter; mut *= a[i].sour; flag = true; } } if (flag) { minn = min(minn, abs(sum - mut)); } return; } st[x] = 1; // 1代表选，2代表不选,0代表未考虑 dfs(x + 1);//这一题只有两种选择，所以直接这样 st[x] = 0; st[x] = 2; dfs(x + 1); st[x] = 0; } 排列型枚举 对于一个位置，有若干种方案选择，他选择了一种，接着下一个位置就只能选择剩下的方案，方案因此逐次递减 题型 N皇后问题（简单的版本是棋盘问题） 分析：\n1.将行视为位置，列视为选择，画出递归树\n2.使用排列枚举方式进行枚举，能够实现每行每列只放一个棋子\n3.使用一个一维数组来记录对于列的选择情况\n棋盘问题acwing1114 棋盘问题的代码模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 15; char g[N][N]; bool st[N]; // 记录已经选过的列 int n, m; // n为几阶方阵，m为棋数目 int res = 0; // 记录方案数 void dfs(int x, int cnt); // x代表第几行，从第一行开始，每个位置有n种选择，并且是排列枚举， // 根据st数组来判断这一列（即选择）是否已经被选过,cnt代表已经选了几个棋子 int main(void) { while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m) != EOF) { if (n == -1 \u0026amp;\u0026amp; m == -1) { break; } cin.ignore(); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i]); } res = 0; dfs(0, 0); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } void dfs(int x, int cnt) { if (cnt == m) { res++; return; } if (x \u0026gt; n - 1) { return; } for (int i = 0; i \u0026lt; n; i++) { if (!st[i] \u0026amp;\u0026amp; g[x][i] == \u0026#39;#\u0026#39;) { st[i] = true; dfs(x + 1, cnt + 1); st[i] = false; } } dfs(x + 1, cnt); // 表示这行我们不放棋子，直接进入下一行 } 八皇后问题：\n题面：\n会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 × 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。\n对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应,a有8个数字，第i个数表示第i行的皇后所处的位数。已经知道8皇后问题一共有92组解。\n现给出一个数b，要求输出第b个合法的八皇后串。串的排序按照字典序从小到大.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 105; bool col[N]; // 存储列状态 bool ls[N]; // 存储左对角线状态 bool rs[N]; // 存储右对角线状态，由于右对角线可能有负数，所以整体平移 int arr[N]; // 记录每行选了哪一列 int ans[100][N]; // 记录答案 void dfs(int x); // x代表当前到第几行 int cnt = 1; int main(void) { int k, b; cin \u0026gt;\u0026gt; k; dfs(1); while (k--) { cin \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= 8; i++) { cout \u0026lt;\u0026lt; ans[b][i]; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } void dfs(int x) { if (x \u0026gt; 8) { for (int i = 1; i \u0026lt;= 8; i++) { ans[cnt][i] = arr[i]; } cnt++; return; } for (int i = 1; i \u0026lt;= 8; i++) { if (!col[i] \u0026amp;\u0026amp; !ls[i + x] \u0026amp;\u0026amp; !rs[i - x + 8]) { col[i] = true; ls[i + x] = true; rs[i - x + 8] = true; arr[x] = i; dfs(x + 1); col[i] = false; ls[i + x] = false; rs[i - x + 8] = false; arr[x] = 0; } } } 分析：\n为何不用二维数组记录斜对角线？因为二维数组记录更适用于不会有回溯记录的情况，这题由于dfs会回溯很多次，所以用二维数组会大幅度增加时间复杂度，所以我们使用一维数组来记录。 rs数组记录右对角线时，因为右对角线可能有负数，所以整体平移，使得右对角线的范围为\u0026gt;=1 如何表示左斜角线和右斜角线？假设皇后在（2、4），对于（1，3）、（3，5）、（4、6）这些在右斜线上的点，都有y-x=定值，同理，左斜线为x+y=定值。于是，就可以得出 左斜角线：ls[i+j]=1;\n右斜角线：rs[i-j+n]=1; n即为行数，此处为8\n排列型枚举的代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int st[N]; //N代表位置的总数所能填写的最大值 void dfs(int x)// x代表当前位置，一般从1开始 { if(x\u0026gt;n) { //根据题目做一些操作 return; } for(int i=1;i\u0026lt;=m;i++)//m代表每个位置能选择m种方案 { if(!st[i]) { st[i]=1; arr[x]=1; dfs(x+1); arr[x]=0; //恢复 st[i]=0; } } } 组合型枚举 对于一个位置，有若干种方案选择，他选择了一种，接着下一个位置能选择的方案必须大于上一个位置选择的方案，这里的大于是指字典序，所以这类题会与数字和字母有关 例题P1025 代码模板（以P1025为例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // 组合枚举 void dfs(int x, int start, int sum); // x代表从位置几开始枚举，start代表枚举数字的起点 int n, k; int res = 0; int main(void) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; dfs(1, 1, 0); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } void dfs(int x, int start, int sum) { if (x \u0026gt; k) { if (sum == n) { res++; } return; } for (int i = start; sum + (k - x + 1) * i \u0026lt;= n; i++) { dfs(x + 1, i, sum + i); } } /*注意，这题如果不进行剪枝操作，会TLE，sum+(k-x+1)*i\u0026lt;=n是剪枝操作 这说的是，如果当前的和加上剩下的数大于n 那么就没有必要继续枚举了 因为我们的位置是要全选完的 所以这种情况绝对最后数会大于n，直接剪枝*/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void dfs(int x,int start)//x代表从位置几开始枚举，start代表枚举数字的起点 { if(x\u0026gt;n) { //根据题目做一些操作 return; } for(int i=start;i\u0026lt;=m;i++)//m代表每个位置能选择m种方案 { arr[x]=i; dfs(x+1,i+1); /*如果是要求下一个选的数大于等于上一个选的数 那么可以dfs（x+1，i）*/ arr[x]=0; //恢复 } } 广度优先搜索 广度优先搜索的特性： 用于图的查找算法（要求能用图表示出问题的关联性） BFS可以用于解决两类问题： 从A出发是否存在到达B的路径 DFS也可求 从A出发到达B的最短路径 DFS如果数据少也可以考虑 BFS是一种用空间换时间的算法，空间复杂度大概为o（2^h），h代表树的高度，2为每次分出来的支数，以二叉树为例 BFS使用的数据结构是队列，可以使用STL中的queue来实现 画出一个树状结构图，每一层都会有若干个节点，每个节点又会有若干个分支，bfs的思路就是从根节点（或者其他节点）开始，访问先访问其直接相连的子节点，若子节点不符合，再访问其子节点的子节点，按级别顺序（一层一层）依次访问，直到访问到目标节点 起始：将起点（源点，树的根节点）放入队列中 扩散：从队列中取出队头的结点，将它的相邻结点放入队列，不断重复这一步 终止：当队列为空时，说明我们遍历了所有的结点，整个图都被搜索了一遍 这种搜索方法，形象点说就像一个水波纹，从源点开始，一层一层的扩散，直到扩散到终点 通过队列实现广度优先搜索，那么队列就具有二段性1，以及单调性2 对于所有边长度相同的情况，比如地图的模型，bfs第一次遇到目标点，此时就一定是从根节点到目标节点的最短路径（因为每一次所有点都是向外扩张一步，你先遇到，一定就最短）。但是，如果是加权边3的话就会出问题了，bfs传回的是经过边数最少的解，但是因为加权了，这个解到根节点的距离不一定是最短的。比如1000+1000是只有两段，1+1+1+1有4段，由于BFS返回的是经过边数最少的解，所以会返回1000+1000的解，此时我们要采用dijkstra最短路算法4解决加权路径的最短路问题。 题型 迷宫问题 多元BFS 染色问题 flood fill 找连通块 有外界干扰的迷宫问题 双向广搜 状态压缩 双端队列广搜 例题： 迷宫问题 例题acwing844.走迷宫是经典模板题，然而要钱，所以题目平替用P1746\n因为都是一个思想，所以我们贴上acwing844的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; #define x first #define y second const int N = 110; int g[N][N]; int n, m; int dis[N][N]; // 存储每个点到起点的距离 int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; // 向量数组，四个方向 上右下左 queue\u0026lt;PII\u0026gt; q; // 存坐标 int bfs(int x1, int y1); int main(void) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; g[i][j]; } } int res = bfs(1, 1); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(int x1, int y1) { // 使用队列模拟广度优先搜索,从起点开始 memset(dis, -1, sizeof(dis)); // 初始化为-1，-1代表与起点不连通，即是1的位置 q.push({x1, y1}); dis[x1][y1] = 0; // 起始点为0 while (q.size()) { PII t = q.front(); // 取出队头 q.pop(); // 弹出 for (int i = 0; i \u0026lt; 4; i++) { int a = t.x + dx[i]; // 上右下左 int b = t.y + dy[i]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; m) // 越界 continue; if (g[a][b] != 0) continue; if (dis[a][b] \u0026gt; 0) continue; q.push({a, b}); /* 入队，根据上右下左，满足的条件的进去 然后以上右下左的顺序出队 假设入队了一个右的，一个下的， 右的先出队就把右的下一个能入队的入队，然后下的再出队 这样就保证了广度优先而不是深度优先, 即一层一层的出队，而不是一条路走到黑*/ dis[a][b] = dis[t.x][t.y] + 1; // 保证了距离是前一个能走的点的距离+1 if (a == n \u0026amp;\u0026amp; b == m) return dis[n][m]; } } return dis[n][m]; } 代码分析、一些常用的习惯：\n向量数组，如果我们要遍历四个方向，我们可以使用向量数组来遍历，这样可以减少代码量并且简洁，假如有斜上方向就是八个了，一般来说以上右下左的方式看，并且我们规定x指向下方，y指向右方（数学中的坐标系顺时针转90°） #define pair\u0026lt;int,int\u0026gt; PII ，这样就可以使用PII来代替pair\u0026lt;int,int\u0026gt;，可以简洁一些 memset，用于初始化数组，第一个参数是数组名，第二个参数是要赋的值，第三个参数是要赋的值的类型，系统用字节数量来判断，所以用sizeof（） 队列实现bfs，为何用队列？正如以上所说，我们需要一层层去遍历到所有结点，那么相邻结点的访问顺序如何确定呢？因此我们就需要一个数据结构去存储和操作，需要使先遍历到的结点先被存储，直到当前层都被存储之后，按照存储的先后顺序，先被存储的结点也会被先取出来，继续遍历他的子节点\u0026ndash;\u0026gt;综上所述，需要一种特点为先进先出的数据结构，也就是队列 例题:P1443 马的遍历\n题目分析：\n这一题与普通迷宫问题不同的是方向向量数组要变化，总共有八种方向选择，并且，这一题如果用STL会有样例过不了，如果确定思路没错，实现代码正确，但是会超时的话，我们就要自己手写队列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 450; int dis[N][N]; int n, m, x, y; int tt = 0, hh = 0; int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2}; int dy[] = {1, 2, 2, 1, -1, -2, -2, -1}; PII q[N * N]; void bfs(int x1, int y1); int main(void) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; bfs(x, y); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cout \u0026lt;\u0026lt; dis[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } void bfs(int x1, int y1) { memset(dis, -1, sizeof(dis)); q[0] = {x1, y1}; dis[x1][y1] = 0; while (hh \u0026lt;= tt) { PII t = q[hh++]; for (int i = 0; i \u0026lt; 8; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; m) continue; if (dis[a][b] \u0026gt;= 0) continue; dis[a][b] = dis[t.first][t.second] + 1; q[++tt] = {a, b}; } } } 手写队列的要点：\n队列的初始化：tt=-1，hh=0 tt即队尾，hh为队头，题目tt=0是因为我们已经初始化进去一个坐标了，队列里本来就有一个 入队：q[++tt]={a,b} 出队：auto t=q[hh++]; 判空：while(hh\u0026lt;=tt) 若是hh\u0026gt;tt就说明队列为空 多元BFS 例题：p1332血色先锋队\n题目分析：\n题目中瘟疫源，即bfs的起点有好几个，此时就要想到，bfs的思想是一层一层的遍历，把起点也算一层，那么我们就需要把所有的起点都入队，自然就能实现多元bfs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 550; queue\u0026lt;PII\u0026gt; q; int dis[N][N]; int n, m, a, b, c, d; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; void bfs(void); int main(void) { memset(dis, -1, sizeof(dis)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = 0; i \u0026lt; a; i++) { int x1, y1; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1); q.push({x1, y1}); dis[x1][y1] = 0; } bfs(); for (int i = 1; i \u0026lt;= b; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d\\n\u0026#34;, dis[c][d]); } return 0; } void bfs(void) { while (q.size()) { PII t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int x = t.first + dx[i]; int y = t.second + dy[i]; if (x \u0026lt; 1 || x \u0026gt; n || y \u0026lt; 1 || y \u0026gt; m) continue; if (dis[x][y] \u0026gt;= 0) /*不需要额外条件判断 画个图就能发现不会出现一个格子上第一次的距离会比第二次 的距离大的情况。第一次标记得到的距离一定会是最小 */ { continue; } dis[x][y] = dis[t.first][t.second] + 1; q.push({x, y}); } } } 染色问题 例题: P1162 填涂颜色\n题目分析：\n此题要把1围成的一个圈内的0都变为2，那么如何判定圈内0和圈外0呢？我们可以用一个二维状态数组，首先用bfs把圈外的0都标记为true，然后在主函数中遍历一遍地图，把为0并且状态数组为false的换为2即可。但是，这类问题要注意边界问题，我们一般起点以（1，1）开始，但是若是坐标（1，1）的点就是1，就不对了。并且，也有可能会出现最上面一些0，中间是一块1圈，最下面还有0，这种情况普通bfs也够不到那些下面的0。\n因此，我们可以把地图扩大一圈，假设地图边界为1\u0026ndash;n，那我们就可以搜索0\u0026ndash;n+1，这样就保证了可以把所有圈外的0标记为true，之后输出的时候再用1-n输出即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 40; int g[N][N]; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; queue\u0026lt;PII\u0026gt; q; bool st[N][N]; void bfs(int x1, int y1); int n; int main(void) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); } } bfs(0, 0); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (g[i][j] == 0 \u0026amp;\u0026amp; st[i][j] == false) { g[i][j] = 2; } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { printf(\u0026#34;%d \u0026#34;, g[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } void bfs(int x1, int y1) { q.push({x1, y1}); st[x1][y1] = true; while (q.size()) { PII t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 0 || a \u0026gt; n + 1 || b \u0026lt; 0 || b \u0026gt; n + 1) continue; if (g[a][b] == 1) continue; if (st[a][b] == true) continue; st[a][b] = true; q.push({a, b}); } } } flood fill 连通块问题 例题:P1451求细胞数量\n题目分析:\n这一题要找非0数字的联通块数，所谓联通块，就是指图中一块都是相同类型的点，本题中连通块的定义为沿连通块数字上下左右若还是连通块数字则为同一连通块,那么我们确定了方向向量是四个方向（有时会是8个方向）,要确定一个连通块，我们就可以分两个步骤，第一步是找到一个连通块的起始点，第二步是从这个起始点开始bfs把所有符合条件的点标记为true，然后连通块数++。如此循环直到所有符合条件点被标记为true，循环结束。标记为true是为了第一步找到的起始点还在以及搜过的连通块中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 110; typedef pair\u0026lt;int, int\u0026gt; PII; char g[N][N]; bool st[N][N]; queue\u0026lt;PII\u0026gt; q; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int n, m; int res = 0; void bfs(int x1, int y1); int main(void) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while (getchar() != \u0026#39;\\n\u0026#39;) { continue; } for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i] + 1); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (g[i][j] != \u0026#39;0\u0026#39; \u0026amp;\u0026amp; st[i][j] == false) { bfs(i, j); res++; } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } void bfs(int x1, int y1) { q.push({x1, y1}); st[x1][y1] = true; while (q.size()) { PII t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; m) { continue; } if (g[a][b] == \u0026#39;0\u0026#39;) { continue; } if (st[a][b] == true) { continue; } q.push({a, b}); st[a][b] = true; } } } 小技巧：若要从g[1][1]开始输入字符串，可以用g[i]+1。\n有外界干扰的迷宫问题 例题:P2895 Meteor Shower S 天降陨石\n题目分析:\n这一题是一道迷宫问题，求出起点到终点的最短路径，但在不同时间段会有陨石干扰，即到达某点的时间不能超过陨石到达的时间。\n那么，我们就能分析出什么点是能走的：\n1.该点始终都没有被陨石砸到\n2.该点未被走过\n3.贝蒂走到该点的时间小于陨石砸到该点的时间\n那么，我们可以开两个二维数组，一个预处理记录所有陨石砸到某点的时间，一个在bfs用于记录贝蒂走到某点的时间\n最短时间在哪找到？这个点始终不会被陨石砸到，只要找到第一个这个点就是最短时间了\n并且，这一题要关注到陨石砸下的位置是可能重复的，所以我们要取所有陨石砸下的时间的最小值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; queue\u0026lt;PII\u0026gt; qt; const int N = 350; int g[N][N]; // 记录了陨石砸在地图上的坐标以及时间点,0代表没被砸到,大于0代表被砸到的时间点 int tim[N][N]; // 记录了每个点到起点需要的时间 // 如何判断一个点是否可以走，dis[x][y]\u0026gt;=g[x][y] 说明不能走 int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int m; int bfs(int x1, int y1); int main(void) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); memset(g, 0x3f, sizeof(g)); for (int i = 1; i \u0026lt;= m; i++) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); g[a][b] = min(g[a][b], c); for (int j = 0; j \u0026lt; 4; j++) { int p = a + dx[j]; int q = b + dy[j]; if (p \u0026lt; 0 || p \u0026gt; 301 || q \u0026lt; 0 || q \u0026gt; 301) { continue; } g[p][q] = min(g[p][q], c); } } int res = bfs(0, 0); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } int bfs(int x1, int y1) { qt.push({x1, y1}); tim[x1][y1] = 0; while (qt.size()) { PII t = qt.front(); qt.pop(); for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 0 || b \u0026lt; 0) { continue; } if (tim[a][b]) { continue; } if (tim[t.first][t.second] + 1 \u0026gt;= g[a][b]) { continue; } tim[a][b] = tim[t.first][t.second] + 1; qt.push({a, b}); if (g[a][b] \u0026gt; 1e9) { return tim[a][b]; } } } return -1; } 小技巧：memset(数组名，0x3f,sizeof(数组名))，可以把数组初始化为无穷大，因为memset是按字节赋值的. 4个字节均为0x3f时，0x3f3f3f3f的十进制是1061109567，也就是10^ 9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。（如果数据远大于1e9就不行了）\nvoid memset(void *s, int ch, size_t n);\n函数解释：\n将s中前n个字节 （typedef unsigned int size_t ）用 ch\n替换并返回 s 。 其实这里面的ch就是ascii为ch的字符；\n将s所指向的某一块内存中的前n个 字节的内容全部设置为ch指定的ASCII值\n双向广搜（满足条件可以使用的优化） 与普通的BFS不同，双向BFS维护的队列中分别有起点搜索出的点和终点搜索出的点，两个点的搜索交替进行。同时，用数组或是哈希表记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束\n使用条件：当起点和终点状态已知，则可以使用\n优点：可以减少时间\n缺点：必须确定起点和终点，在对状态进行标记时往往涉及状态的压缩\n例题:P1746离开中山路\n运用数组的双向广搜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;bits/stdc++.h\u0026gt; //双向广搜优化 using namespace std; const int N = 1100; typedef pair\u0026lt;int, int\u0026gt; PII; int n; char g[N][N]; int dist[N][N]; int vis[N][N]; queue\u0026lt;PII\u0026gt; qt; int a, b, c, d; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int bfs(void); int main(void) { cin \u0026gt;\u0026gt; n; cin.ignore(); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i] + 1); } cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int res = bfs(); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(void) { memset(dist, -1, sizeof(dist)); // dist存（i，j）到起点的距离 memset(vis, -1, sizeof(vis)); // vis[i][j]表示(i,j)的标记 1是起点开始搜，2是终点开始搜 dist[a][b] = 0; dist[c][d] = 0; vis[a][b] = 1, vis[c][d] = 2; qt.push({a, b}); qt.push({c, d}); while (qt.size()) { PII t = qt.front(); qt.pop(); for (int i = 0; i \u0026lt; 4; i++) { int x = t.first + dx[i]; int y = t.second + dy[i]; if (x \u0026lt; 1 || x \u0026gt; n || y \u0026lt; 1 || y \u0026gt; n) continue; if (g[x][y] != \u0026#39;0\u0026#39;) continue; if (vis[x][y] + vis[t.first][t.second] == 3) // 说明此时有个交点，起点与终点的搜索相遇 { return dist[x][y] + dist[t.first][t.second] + 1; } if (dist[x][y] \u0026gt;= 0) { continue; } dist[x][y] = dist[t.first][t.second] + 1; // 拓展队头的子节点 if (vis[x][y] == -1) // vis为-1就说明这个点没有被拓展过，那么就根据上一个点的vis进行标记 { vis[x][y] = vis[t.first][t.second]; } qt.push({x, y}); } } return -1; } 例题二：p1379 八数码难题\n运用哈希表的双向广搜，并且运用了状态压缩的方法\n题目分析:\n根据题目，我们可以画出搜索树，但是问题是如何表示状态呢，用二维数组表示状态会十分麻烦，不过题目给了我们提示，使用一维的字符串，这就是状态压缩，将二维降维为一维,同时，我们可以用哈希表记录状态是否被访问过，还有，这题给出了起点和终点，所以我们还可以双向广搜（双向广搜作为一个优化的办法，如果题目数据不大，可以不用，毕竟代码量多容易错）\n状态压缩：首先，我们要明确用一维字符串进行状态的存储，假如要进行变换，那就要用二维数组进行，所以，我们要解决一维变二维和二维变一维的问题\n题目中规定了矩阵是3*3的，那么，用一维数组下标来表示二维数组的行和列，就是一维数组下标/3\u0026ndash;\u0026gt;行,一维数组下标%3\u0026ndash;\u0026gt;列(注意这里以(0,0)开头)\n题目只要求移动0，所以我们就可以找到0的位置(string.find(\u0026lsquo;0\u0026rsquo;)),然后再表示即可 若要将二维下标转为一维，则是一维下标=二维行下标*3+二维列下标.\n哈希表：哈希表其实就是stl中的map或unordered_map容器，我们把每次的状态作为key-键，变换次数作为值，这样就可以记录状态是否被访问过\n双向广搜：这里要注意的就是记录情况要用哈希表\n无优化的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string end1 = \u0026#34;123804765\u0026#34;; // 状态压缩 unordered_map\u0026lt;string, int\u0026gt; dist; // 哈希表 queue\u0026lt;string\u0026gt; q; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; // 上下左右四个方向 int bfs(string start); int main() { string start; cin \u0026gt;\u0026gt; start; int res = bfs(start); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(string start) { q.push(start); dist[start] = 0; while (q.size()) { auto t = q.front(); q.pop(); if (t == end1) { return dist[t]; } int distance = dist[t]; // 取出当前状态的距离 // 一维数组下标转换为二维数组下标（找到0的位置--\u0026gt;一维数组下标--\u0026gt;二维数组下标） int ta = t.find(\u0026#39;0\u0026#39;); int tx = ta / 3; // 实现字符串转换为3*3的矩阵（这个矩阵是从(0,0)开始的) int ty = ta % 3; // tx第几行，ty第几列 for (int i = 0; i \u0026lt; 4; i++) { int a = tx + dx[i]; int b = ty + dy[i]; if (a \u0026lt; 0 || a \u0026gt;= 3 || b \u0026lt; 0 || b \u0026gt;= 3) continue; int temp = a * 3 + b; // 实现二维数组下标转换为一维数组下标 swap(t[ta], t[temp]); // 如果这个状态没有出现过，则加入队列，并计算距离 if (!dist.count(t)) // count函数 看map中有没有key值为t的元素，如果有则返回1，没有则返回0 { dist[t] = distance + 1; q.push(t); } swap(t[ta], t[temp]); // 恢复现场,为下个方向做准备 } } return -1; } 使用双向广搜的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string end1 = \u0026#34;123804765\u0026#34;; unordered_map\u0026lt;string, int\u0026gt; dist; unordered_map\u0026lt;string, int\u0026gt; st; // 1代表起点标记，2代表终点标记 queue\u0026lt;string\u0026gt; q; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; int bfs(string start); int main(void) { string start; cin \u0026gt;\u0026gt; start; int res = 0; if (start == end1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } res = bfs(start); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(string start) { q.push(start); dist[start] = 0; st[start] = 1; q.push(end1); dist[end1] = 0; st[end1] = 2; while (q.size()) { auto t = q.front(); q.pop(); int flag = st[t]; // 取出当前状态的标记 int distance = dist[t]; // 取出当前状态的距离 int ta = t.find(\u0026#39;0\u0026#39;); int tx = ta / 3; int ty = ta % 3; for (int i = 0; i \u0026lt; 4; i++) { int c = tx + dx[i]; int d = ty + dy[i]; if (c \u0026lt; 0 || c \u0026gt;= 3 || d \u0026lt; 0 || d \u0026gt;= 3) continue; int temp = c * 3 + d; swap(t[ta], t[temp]); if (st[t] + flag == 3) { return dist[t] + distance + 1; } if (!dist.count(t)) { dist[t] = distance + 1; st[t] = flag; q.push(t); } swap(t[ta], t[temp]); } } return 0; } 注意事项：\n关于map与unordered_map，他们区别在于map会对键值进行排序，按照字典序从小到大，unordered_map是无序的 关于map.count(t)函数，如果map中存在key值为t的函数，则返回1，否则返回0，注意由于map和unordered_map具有互异性，所以才只返回1，这可以用来判断状态是否被访问过 map与unordered_map在未被访问时是没有默认值的，而一旦有涉及到map[t]的操作时，就会自动创建一个key值为t的元素，并赋予默认值，所以在使用map时，如果要判断状态是否被访问过，就不能直接用map[t]，而是要用map.count(t) 状态压缩 状态压缩的目的是将一个二维的状态转为一维，这样记录状态会十分方便，涉及到状态压缩一般就会使用字符串和哈希表\n例题：P2730 [USACO3.2] 魔板 Magic Squares\n题目分析:\n这题的难点有三个，第一个是如何表示状态，第二个是如何输出到达目标状态使用的所有基本操作，第三个是如何实现这三种基本操作\n状态表示：这题是一个2*4的矩阵，显然我们可以用状态压缩表示状态，关键是如何进行三种基本操作。 如何输出到达目标状态使用的所有基本操作：首先我们要知道如何记录到达一个状态所用的基本操作，我们可以用哈希表记录，那么键为当前状态，并且，我们还可以再记录上一个状态，方便输出，值就为pair\u0026lt;char,string\u0026gt;\u0026ndash;\u0026gt;first为基本操作，second为上一个状态,如此只要从目标状态开始，不断地回溯到起点，就可以得到逆序的基本操作表，再反转函数用一下就好了 如何实现这三种基本操作：这题的三种基本操作，就是中心顺时针旋转，最后一列迁移到第一列，上下交换，这三种操作把涉及到了大部分元素，所以我们无法像八数码那样部分的转换，因此我们开一个二维数组专门进行，我们可以用一个get1函数实现一维变二维，再用一个get2函数实现二维变一维。然后再用3个函数分别实现这三种基本操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; unordered_map\u0026lt;string, int\u0026gt; dist; // 存到当前状态需要几步 unordered_map\u0026lt;string, pair\u0026lt;char, string\u0026gt;\u0026gt; pre; // 存从哪一个状态转移过来，而且要存A还是B还是C操作 queue\u0026lt;string\u0026gt; q; char g[10][10]; // 把一维字符串转为二维数组 void set1(string t) { for (int i = 0; i \u0026lt; 4; i++) { g[0][i] = t[i]; } for (int i = 3, j = 4; i \u0026gt;= 0; i--, j++) { g[1][i] = t[j]; } } // 把二维数组转换为一维字符串 string get1() { string res; for (int i = 0; i \u0026lt; 4; i++) { res += g[0][i]; } for (int i = 3; i \u0026gt;= 0; i--) { res += g[1][i]; } return res; } int bfs(string start, string end1); string move0(string t); string move1(string t); string move2(string t); int main(void) { int x; string start, end1; for (int i = 1; i \u0026lt;= 8; i++) //考虑到题目中有空格，所以要把数字转换为字符 { cin \u0026gt;\u0026gt; x; end1 += x + \u0026#39;0\u0026#39;; } for (int i = 1; i \u0026lt;= 8; i++) { start += i + \u0026#39;0\u0026#39;; } int res = bfs(start, end1); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; string res2; while (end1 != start) { res2 += pre[end1].first; // 这样得出的是逆序的操作表 end1 = pre[end1].second; } reverse(res2.begin(), res2.end()); // 反转，使用迭代器 if (res2.size()) { cout \u0026lt;\u0026lt; res2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } int bfs(string start, string end1) { q.push(start); dist[start] = 0; while (q.size()) { auto t = q.front(); q.pop(); if (t == end1) // 假如基础状态就是目标状态的情况这个if会被使用 { return dist[end1]; } string m[3]; m[0] = move0(t); m[1] = move1(t); m[2] = move2(t); for (int i = 0; i \u0026lt; 3; i++) { string s = m[i]; if (!dist.count(s)) { dist[s] = dist[t] + 1; pre[s] = {char(i + \u0026#39;A\u0026#39;), t}; //(用哪个操作过来的，变换后的串) if (s == end1) { return dist[end1]; } q.push(s); } } } return -1; } string move0(string t) // A变换 { set1(t); for (int i = 0; i \u0026lt; 4; i++) { swap(g[0][i], g[1][i]); } return get1(); } string move1(string t) // B变换 { set1(t); // 通过交换实现 for (int i = 3; i \u0026gt;= 1; i--) { swap(g[0][i], g[0][i - 1]); swap(g[1][i], g[1][i - 1]); } return get1(); } string move2(string t) // C变换 { set1(t); // 把中间四个数中左上角的数存起来，然后直接转一圈 char temp = g[0][1]; g[0][1] = g[1][1]; g[1][1] = g[1][2]; g[1][2] = g[0][2]; g[0][2] = temp; return get1(); } 双端队列广搜 与普通广搜不同的是，双端队列广搜使用的容器是deque双端队列 使用条件：状态只有两种，保证单调性\n例题:P4554 小明的游戏\n题目分析:\n根据题目，想要花费最少就要先走完所有费用0的格子,然后再走费用为1的格子，我们把费用0和费用1的格子视为两种状态，那么就符合了队列的两段性，但是如果只是普通队列，我们没办法使费用0的格子先全部走完，再走费用1的格子，这时我们可以用双端队列，将费用0的格子从队头入队，费用1的格子从对尾入队，这样就可以使费用0的格子全部走完再走费用1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 510; char g[N][N]; int dis[N][N]; int n, m; int x, x2, y, y2; deque\u0026lt;PII\u0026gt; q; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int bfs(int x, int y); int main(void) { while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m, n || m) { for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i]); } memset(dis, -1, sizeof(dis)); q.clear(); cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int res = bfs(x, y); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } int bfs(int x, int y) { q.push_back({x, y}); dis[x][y] = 0; while (q.size()) { PII t = q.front(); q.pop_front(); char ch = g[t.first][t.second]; for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 0 || a \u0026gt;= n || b \u0026lt; 0 || b \u0026gt;= m) continue; if (dis[a][b] \u0026gt;= 0) { continue; } if (g[a][b] == ch) { dis[a][b] = dis[t.first][t.second] + 0; // 状态不会变 q.push_front({a, b}); } if (g[a][b] != ch) { dis[a][b] = dis[t.first][t.second] + 1; // 状态会增加 q.push_back({a, b}); } if (a == x2 \u0026amp;\u0026amp; b == y2) { return dis[x2][y2]; } } } return -1; } 搜索总结 深度优先搜索的关键词：\n一条路走到黑 回溯 栈 剪枝 广度优先搜索的关键词：\n水波纹，一层一层 不存在回溯，可以使用额外的数据结构进行记录以实现回溯 队列 图，迷宫，最短路 额外知识补充 曼哈顿距离:\n曼哈顿距离（Manhattan Distance）是由十九世纪的赫尔曼·闵可夫斯基所创词汇 ，是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。\n曼哈顿距离——两点在南北方向上的距离加上在东西方向上的距离，即d(i,j)=|xi-xj|+|yi-yj|。（横平竖直的距离）\n还有一种常用距离是欧几里得距离，欧几里得距离——两点在欧几里得空间中的距离，即d(i,j)=sqrt((xi-xj)^2+(yi-yj)^2)。（斜着的距离）\n任何时刻，队列中最多存在两种状态\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n前一段状态为x，后一段状态为x+1\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n加权边的意思是给边长度赋值，原本边长度都默认为1，结果加权边给他们赋不同的值，100，500，600这样子\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ndijkstra算法可以在图论的相关学习中学到\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-12-15T00:00:00Z","image":"https://baoziandbluemouse.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%90%9C%E7%B4%A2/huosuzhanshiba_hu_36ba7a14166484ce.jpg","permalink":"https://baoziandbluemouse.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%90%9C%E7%B4%A2/","title":"算法学习-搜索"}]