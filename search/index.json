[{"content":"前言 学习网站:https://www.starrycoding.com/\n本篇文章涉及位运算，排序，双指针，二分.\n位运算 如图，位运算有这几种操作,比较常出现的是异或和与。\n与的应用：作为掩码来使用。 如000111 \u0026amp; 000001= 000001，这样就可以取出最后一位。\n异或的性质:\n注：因为异或满足结合律，所以异或运算可以进行类似前缀和的预处理\n例题 P51 二进制中1的个数:https://www.starrycoding.com/problem/51\n分析：朴素算法就是把数字转成二进制，然后统计1的个数，实现的话我们就可以用掩码来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 10; typedef long long ll; ll f(int x) { ll res = 0; while (x \u0026gt; 0) { if (x \u0026amp; 1 == 1) res++; x \u0026gt;\u0026gt;= 1; } return res; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, x; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; f(x) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } P52 我们需要0:https://www.starrycoding.com/problem/52\n分析： 这题定义了$b_i=a_i⊕x$，并且要使得$b_1⊕b_2⊕\u0026hellip;⊕b_n=0$ 那么我们把$b_1⊕b_2⊕\u0026hellip;⊕b_n$拆开，那么就可以转化成$a_1⊕a_2⊕\u0026hellip;⊕a_n⊕x⊕x⊕\u0026hellip;⊕x=0$ （运用了交换律） 这里再运用异或的性质，即$x⊕x=0$，那么就可以转化成\n$$a_1⊕a_2⊕...⊕a_n⊕x=0$$$$a_1⊕a_2⊕...⊕a_n⊕x=x⊕x$$$$a_1⊕a_2⊕...⊕a_n⊕x⊕x=x⊕x⊕x$$$$a_1⊕a_2⊕...⊕a_n=x$$所以我们就能得到x了，也知道x是必定存在且唯一的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;bits/stdc++.h\u0026gt; //运用异或性质+结合律,a^b^c=a^(b^c)+交换律,a^b^a=a^a^b=0^b=b using namespace std; // 异或性质：a^a=0,a^0=a const int N = 1e3 + 10; typedef long long ll; ll arr[N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t, n; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } int res = 0; for (int i = 1; i \u0026lt;= n; i++) { res ^= arr[i]; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } P53 Mex and Xor:https://www.starrycoding.com/problem/53\n分析: 根据题目定义 MEX值是指：最小的不存在于该数组之中的非负整数。 例：$a=[0,3,2,2]$,则$MEX(a)=1$。\nXOR值是指：数组中的所有元素做异或运算的结果。 例:$a=[3,5,5]$,则$XOR(a)=3⊕5⊕5=3$。\n给定了MEX值与XOR值，我们要求出满足这两值的非负整数数组的最小长度。因为长度最小，可以认为arr数组必须具有有序性，以及互异性.\n假设MEX值为a，XOR值为b,假设有序数组为$arr=[0,1,2,3,4,5\u0026hellip;a-1,a+1,a+2,a+3\u0026hellip;]$\n我们可以发现arr被分成了两部分，一部分是$[0,a-1]$，将这部分设为$x$,因为我们的arr要保证最小长度，所以这部分值是确定的,另一部分是$[a+1\u0026hellip;.]$，将这部分设为$y$\n则有\n①.$x⊕y=b$\n②.$y=x⊕b$\n根据y的值不同我们就可以得到不同的数组长度结果，所以接下来我们开始分类讨论\n1.y=0时，那么就说明x=b，此时数组长度就为a\n2.y=a时，因为我们不能有a，所以要把a拆成两个数（不难发现，一个数字a必定能拆成两个数的异或）,所以此时数组长度就为a+2\n3.y!=a且y!=0时，此时数组长度就为a+1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; //异或运算，异或前缀和 using namespace std; const int N = 2e5 + 9; int prexor[N]; void solve() { int len = 0; int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int y = prexor[a - 1] ^ b; if (y == 0) { len = a; } else if (y == a) { len = a + 2; } else { len = a + 1; } cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= 2e5; i++) { prexor[i] = prexor[i - 1] ^ i; } while (t--) { solve(); } return 0; } 注：此处[1,a-1]的值要用异或前缀和来预处理。\n排序 模板一:https://www.starrycoding.com/problem/54\n通过排序去重（类似set）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; //运用排序，动态数组，unique实现去重 using namespace std; // 另一种去重办法使用set vector\u0026lt;int\u0026gt; a; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; a.push_back(x); } sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); // unique函数实际是把重复的数移到后面去了 // 最终函数会返回不重复的数的最后一个位置的后一个位置(迭代器),然后我们再用erase函数删除后面的数即可 // unique函数只能把相邻的重复数删除，所以我们需要先排序 // unique返回的是迭代器 for (auto \u0026amp;i : a) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 模板二:https://www.starrycoding.com/problem/55\n使用了比较器的排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; struct book { int a, b, c; } p[N]; bool cmp(struct book a, struct book b) // 自定义比较器 以降序为例，如果你要降序，那么a\u0026gt;b就要返回true,否则返回false { if (a.a != b.a) { return a.a \u0026gt; b.a; } if (a.b != b.b) { return a.b \u0026gt; b.b; } return a.c \u0026gt; b.c; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; p[i].a \u0026gt;\u0026gt; p[i].b \u0026gt;\u0026gt; p[i].c; } sort(p + 1, p + n + 1, cmp); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; p[i].a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p[i].b \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p[i].c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们要定义的该比较操作为$⋆$\n若$a⋆b$，则比较器函数应当返回true\n若$a!⋆b$，则比较器函数应当返回false\n模板三:https://www.starrycoding.com/problem/56\n桶排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 3e6 + 10; int arr[N]; int main(void) { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; arr[x]++; } for (int i = 0; i \u0026lt;= 2e5; i++) { for (int j = 0; j \u0026lt; arr[i]; j++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 双指针 如图，我们可以看到双指针的核心就是i,j的移动,我们以具体题目来解释\nP36 最长连续不重复子序列:https://www.starrycoding.com/problem/36\n分析： 根据题目，我们要找出数组中最长的无重复的子序列,用双指针来实现\n由图，我们区间内维护的是无重复子序列的长度，那么我们j的移动条件就是区间内无重复，i的移动条件就是区间内有重复，并且每当我们的j+1是重复时，就可以对ans进行max判断.\n如何判断区间内有重复呢？我们可以使用桶来实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5 + 9; typedef long long ll; int arr[N], c[N]; void solve(void) { int n; ll maxx = -1; cin \u0026gt;\u0026gt; n; memset(arr, 0, sizeof(int) * n + 1); // 初始化数组 for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } for (int i = 1; i \u0026lt;= n; i++) { c[arr[i]] = 0; // 初始化桶 } for (int i = 1, j = 0; i \u0026lt;= n; i++) { while (j \u0026lt; n \u0026amp;\u0026amp; !c[arr[j + 1]]) { j++; c[arr[j]]++; } maxx = max(maxx, j - i + 1ll); c[arr[i]]--; } cout \u0026lt;\u0026lt; maxx \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } 二分 二分讲解:https://www.bilibili.com/video/BV1fA411z7ru\n模板:https://www.starrycoding.com/problem/57\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5 + 9; typedef long long ll; int arr[N]; int n, q, x; bool check(ll mid) { return arr[mid] \u0026lt; x; } void solve(void) { cin \u0026gt;\u0026gt; x; ll l = 0, r = n + 1, mid = 0; while (l + 1 != r) { mid = (l + r) / 2; if (check(mid)) { l = mid; } else { r = mid; } } if (arr[r] == x) { cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } while (q--) { solve(); } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 使用条件：答案具有单调性\n关键词: 最大最小值，最小最大值\n求最小要找答案的下界，求最大要找答案的上界\n以l，r作为两个指针来理解\n建模：确立蓝红区域（分界线） 确定check（）函数（根据分界线来写 分界线左边的数字都有什么性质，右边又有什么性质） 确定返回r还是l 套用模板 二分一次只能出一个答案（r或l） l，r初始值是开区间的左右端点,以数组下标0开头的话，l=-1，r=N（如果l，r代表数字的话，就是答案数据范围的左右端点） 例题 P37 进击的奶牛:https://www.starrycoding.com/problem/37\n分析： 最近距离就是指相邻的两头牛的距离，这个距离越大越好\n也就是说我们假设所有相邻距离集合为A，最大的相邻距离为max,那么A必须满足\n任选A中一个元素，都大于等于max,则此max为最小最大值 (所有种的A中的最小元素的集合中的最大值)\n对样例分析，我们可以得出二分分界线：给定最小相邻距离，能否放下要求放的牛数量\n由图，我们知道了最小相邻距离与能放下的牛数量的关系，那么我们就可以用二分来实现了。并且，由于left左端是$(max)_c\u0026gt;=x$的,left会不断右移直到下一个值不会大于等于x,所以left会是最小最大值。\n（同理，我们能知道假如right是$(max)_c\u0026lt;=x$的话，right会不断左移直到right左边的值大于x,最终会得到$r=1$,并非所求值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 9; int n, c; int arr[N]; bool check(ll mid) { int j = 1; int cnt = 1; // 注意这里牛已经在第一个位置放了一头了 for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] - arr[j] \u0026gt;= mid) { cnt++; j = i; } } return cnt \u0026gt;= c; } int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } sort(arr + 1, arr + n + 1); ll l = 0, r = 1e9 + 10, mid = 0; while (l + 1 != r) { mid = (l + r) / 2; if (check(mid)) { l = mid; } else { r = mid; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2025-01-11T00:00:00Z","image":"https://baozi.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/zhenhong_hu16488590154627571093.jpg","permalink":"https://baozi.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/","title":"算法学习"},{"content":"前言 学习网站:https://www.starrycoding.com/\n前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。\n前缀和 前缀和预处理可以帮助我们在$O(1)$的时间复杂度内求出$a$数组中任意区间$[l,r]$的和，即$a_l+a_{l+1}+a_{l+2}+\u0026hellip;+a_r$，而不需要每次都遍历一遍区间，这大大提高了查询的效率。\n前缀和通常用数组来实现,假设我们有一个数组a，那么我们可以用数组b来表示a的前缀和，即\n$$b_1=a_1,b_2=a_1+a_2,b_3=a_1+a_2+a_3....$$如此循环，直到加到$b_n$，那么$b_n$就是a的所有元素之和 一维前缀和题目:https://www.starrycoding.com/problem/7\n模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t, n, q; cin \u0026gt;\u0026gt; t; while (t--) { vector\u0026lt;ll\u0026gt; arr(100010); vector\u0026lt;ll\u0026gt; sum(100010); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } sum[1] = arr[1]; for (int i = 2; i \u0026lt;= n; i++) { sum[i] = sum[i - 1] + arr[i]; // 前缀和处理 } int l = 0, r = 0; while (q--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll res = sum[r] - sum[l - 1]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } return 0; } 补充：二维前缀和 二维前缀和思想和一维的一致，只不过我们需要二维数组来实现，并且初始化也会有所不同\n二维前缀和题目:https://www.starrycoding.com/problem/15\n如图即为二维前缀和的初始化（少加了$a_{3,3}$），我们假设一个二维数组a，我们用二维数组b来表示a的二维前缀和，即\n$$b_{3,3}=b_{2,3}+b_{3,2}-b_{2,2}+a_{3,3}$$这涉及了一点递归（递推）的思想（可以自己从1，1开始推一下）\n模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1200; int g[N][N]; ll prefix[N][N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; g[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + g[i][j]; } } int x_l, y_l, x_r, y_r; while (q--) { cin \u0026gt;\u0026gt; x_l \u0026gt;\u0026gt; y_l \u0026gt;\u0026gt; x_r \u0026gt;\u0026gt; y_r; ll res = 0; res = prefix[x_r][y_r] + prefix[x_l - 1][y_l - 1] - prefix[x_r][y_l - 1] - prefix[x_l - 1][y_r]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 差分 差分的作用是在$O(n)$ (n为修改数值次数)的时间复杂度内，将$a$数组中$[l,r]$区间的所有数加上一个数$c$，而不需要每次都遍历一遍区间，这同样也是一种预处理从而增加效率的方式。 需要注意的是通过差分实现区间修改，是一种静态维护,也就是说我们只能在修改完才能询问，而无法边修改边询问。\n假设我们有一个数组a，用数组b来表示a的差分，即\n$$b_1=a_1,b_2=a_2-a_1,b_3=a_3-a_2....$$这里我们可以发现一个规律，如果得出b数组的前缀和,那么就有\n$$b_1+b_2+...b_i=a_1+a_2-a_1+...a_i-a_{i-1}$$ 即\n$$b_1+b_2+...b_i=a_i$$我们由此得出差分的性质就是可以通过差分的前缀和来得到原数组的其中一个元素。 基于差分的这个性质，我们就可以用差分来实现静态的区间修改 如果我们给差分数组d中的$d_2$加上一个数$x$,那么用前缀和还原时，就会发现从$a_2$开始所有的数都加上了$x$ 那假如我们要给$[2,3]$区间加上一个数$x$呢？\n$$d_l+=x,d_{r+1}-=x$$此时，我们再回过头看开头时我们是如何表示差分的,就可以发现其实他们也遵循了这个修改区间的公式,只不过他们的区间很小,是$[1,2]$,$[2,3]$,$[3,4]$\u0026hellip;以此类推下去。 注:一维差分数组可以直接用$d_i=a_i-a_{i-1}$来表示，而二维差分数组我们一般用上面的公式来初始化\n一般来说，差分题目在修改完区间后，就会询问区间和，所以还会需要再进行一次前缀和\n一维差分题目:https://www.starrycoding.com/problem/8 模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 9; ll arr[N]; ll differ[N]; ll prefix[N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, p, q; ll x = 0, l = 0, r = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; } for (int i = 1; i \u0026lt;= n; i++) { differ[i] = arr[i] - arr[i - 1]; // 差分处理 } while (p--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; differ[l] += x; differ[r + 1] -= x; // 修改区间 } for (int i = 1; i \u0026lt;= n; i++) { arr[i] = arr[i - 1] + differ[i]; // 通过差分还原数组，并且数据经过修改 } for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + arr[i]; // 前缀和 } while (q--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll res = 0; res = prefix[r] - prefix[l - 1]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 补充：二维差分 二维差分的特点就如前面所说，我们初始化需要使用公式才会更有助于理解 二维差分题目:https://www.starrycoding.com/problem/50\n由图，我们先假设我们已经初始化了一个二维差分数组，图上这些格子内部便是坐标点,现在我们要给$[2,2]$到$[4,4]$区间加上一个数$x$ 就应该把$d_{2,2}$加上$x$，$d_{4+1,2}-=x$,$d_{2,4+1}-=x$,$d_{4+1,4+1}+=x$\n同理，我们初始化也可以如此操作\n$$d_{x_1,y_1}+=x,d_{x_2+1,y_1}-=x,d_{x_1,y_2+1}-=x,d_{x_2+1,y_2+1}+=x$$模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1100; int arr[N][N]; int differ[N][N]; int prefix[N][N]; int main(void) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, m, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; arr[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { differ[i][j] += arr[i][j]; // 这里差分初始化用的原理和下面一样 differ[i + 1][j] -= arr[i][j]; // 和下面不一样的是因为就只要一个格子变，所以左上右下的坐标都是(i,j) differ[i][j + 1] -= arr[i][j]; differ[i + 1][j + 1] += arr[i][j]; } } int a, b, c, d, v; while (q--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; v; differ[a][b] += v; differ[a][d + 1] -= v; differ[c + 1][b] -= v; differ[c + 1][d + 1] += v; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { arr[i][j] = arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1] + differ[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 好题解析 涉及:?运算符的应用,最大子段和\n题目p35.鼠鼠我鸭\n分析：题目将重量分为两种类型，一种可以算进答案，一种不行，并且，我们可以使用一次操作来变更一段区间$[l,r]$的类型，我们可以用一个bool数组来记录，0代表不行，1代表可以,既然要求最大值，那么我们可以先把未改变时的答案求出来,接着再求更改时的增加量。\n如图，想要实现这个功能可以运用？运算符(不过此题也可以直接乘以bool数组来实现)\n接着，观察题目不难发现，更改后的答案绝对是要\u0026gt;=未改变时的答案的，所以我们只需要比较更改后的增加量和0的大小即可。 此时要求出这个增加量，我们可以先初始化一个全变更的数组（偏移量数组），接着在这个数组中求出最大子段和即可。\n这里有两种求最大子段和的方法:\n前缀和求法 我们将偏移量数组求前缀和，然后用$prefix_r-prefix_{l-1}$来求出最大子段和（要使fix最大，就要使$prefix_{l-1}$在区间$[0,r-1]$为确定的最小值,然后再枚举$prefix_r$即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 ll minn = 0; // minn默认为0是因为prefix[]中的元素从1开始，而我们要找prefix[l-1]的最小值是可以超出下标的， // 所以绝对会找到prefix[0]，则minn可以取0 for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + a[i] * (w[i] ? -1 : 1); } ll fix = 0; for (int i = 1; i \u0026lt;= n; i++) // 求偏移量的最大字段和方法(使用前缀和) { fix = max(fix, prefix[i] - minn); minn = min(minn, prefix[i]); } 贪心求法 如果mx\u0026lt;0,则将其重置为0,然后再加上a[i]即可,最后再用mx更新答案即可。 思想：如果当前的字段和为负数，那么下一次加数字时，我们选择重置为0再加绝对会比直接加的数字大\n1 2 3 4 5 ll mx = 0; for (int i = 1; i \u0026lt;= n; i++) { mx = max(0ll, mx + a[i] * (w[i] ? -1 : 1)); } 题目答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 9; ll a[N]; bool w[N]; ll prefix[N]; int n; int main(void) { ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } ll sum = 0; ll ess = 0; ll minn = 0; // minn默认为0是因为prefix[]中的元素从1开始，而我们要找prefix[l-1]的最小值是可以超出下标的， // 所以绝对会找到prefix[0]，则minn可以取0 for (int i = 1; i \u0026lt;= n; i++) { ess += a[i] * w[i]; } for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + a[i] * (w[i] ? -1 : 1); } ll fix = 0; for (int i = 1; i \u0026lt;= n; i++) // 求偏移量的最大字段和方法(使用前缀和) { fix = max(fix, prefix[i] - minn); minn = min(minn, prefix[i]); } ll ans = ess + fix; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","date":"2025-01-01T00:00:00Z","image":"https://baozi.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/mu_hu9062499207091527563.jpg","permalink":"https://baozi.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","title":"算法学习-前缀和与差分"},{"content":"学习视频链接:https://www.bilibili.com/video/BV1UH4y1z7JU/\n为何cpp输入输出会变慢（和C相比） iostream i/o 与 stdio i/o 保持同步带来的耗时（取消同步流） cin 与 cout 存在绑定耗费时间 endl相比\\n 耗时 上述三个原因对于c来说都是没有的，因此在cpp中使用c风格的输入输出可以极大的提速。 但是c风格的输入输出更适合格式化输出，没有cin和cout的便捷，因此想要同时拥有便捷和速度的话就要解决这三个问题\n取消同步流 什么是同步流？ 同步指的是c输出输入与cpp输出输入保持同步，由于cpp为了兼容c，c输出输入与cpp输出输入使用的是同一块缓冲区，我们将其称为c流缓冲区 如图所示，这个同步操作带来了耗时，我们可以通过以下代码取消同步流\n1 ios::sync_with_stdio(false); 取消cin与cout绑定 什么是cin与cout绑定？ 这是使输入输出更加安全的一个操作，绑定指的是每次cin输入前都会刷新cout缓冲区\n解除绑定操作如下\n1 2 cin.tie(0); cout.tie(0); 值得注意的是，cout.tie(0)这个语句似乎是多余的，因为cout本来就与null绑定了,不过由于大家都这么写，所以还是写上\n用\u0026rsquo;\\n\u0026rsquo;代替endl 为何endl会比\u0026rsquo;\\n\u0026rsquo;慢？ 实际上endl=\u0026rsquo;\\n\u0026rsquo; + 强制刷新缓冲区 也就是说\n1 cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;flush; 与\n1 cout\u0026lt;\u0026lt;endl; 是一样的，所以就是这个多出来的强制刷新缓冲区导致的耗时 \u0026lsquo;\\n\u0026rsquo;本身是不会刷新缓冲区的，他会在下一行代码执行时刷新缓冲区 endl本身是会刷新缓冲区的，并且，在下一行代码执行时他还会再次刷新 也就是说，endl会比\u0026rsquo;\\n\u0026rsquo;多刷新一次缓冲区，所以会慢一些\n其实这也是一种安全性的措施，endl保证了在程序崩溃时，能完成输出，而\u0026rsquo;\\n\u0026rsquo;则不能\n总结 使cpp风格输入输出提速的解决方法就是\n取消同步流 取消cin与cout绑定 用\u0026rsquo;\\n\u0026rsquo;代替endl 1 2 3 4 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cout\u0026lt;\u0026lt;something\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; ","date":"2024-12-28T00:00:00Z","image":"https://baozi.github.io/p/cpp%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8F%90%E9%80%9F%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/card-normal_hu12975287803311279965.jpg","permalink":"https://baozi.github.io/p/cpp%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8F%90%E9%80%9F%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/","title":"cpp输入输出提速底层分析"},{"content":"搜索专题 搜索算法，包括深度优先搜索和广度优先搜索，从起点开始，逐渐扩大寻找范围，直到找到需要的答案为止。\n严格来说，搜索算法也算是一种暴力枚举策略，但是其算法特性决定了效率比直接的枚举所有答案要高，因为搜索可以跳过一些无效状态，降低问题规模。在算法竞赛中，如果选手无法找到一种高效求解的方法（比如贪心、递推、动态规划、公式推导等），使用搜索也可以解决一些规模较小的情况；而有的任务就是必须使用搜索来完成，因此这是相当重要的策略。\n学习视频链接:https://www.bilibili.com/video/BV1N24y1W7q4/\n深度优先搜索 深度优先搜索的特性： 搜索过程中会沿着一条路径一直走到底，直到不能走为止，然后退回到上一个节点，继续搜索。 搜索使用到的数据结构是栈，可以使用递归实现，草稿时可以画出一个树状结构来辅助理解。 根据树状结构图，我们可以得出搜索的两个基本点，一个是位置有多少，一个是每个位置上有多少中选择 空间复杂度大概就是o(h),h为树高 深度优先搜索具有三种基本形式： 指数级枚举 对于一个位置，有若干种选择，他能选择其中的任何一种，接着下一个位置同样能选择其中的任何一种，不会因为已选择位置的增加而使方案选择变少，若有n个位置，每个位置有m种选择，则总方案数为m^n。时间复杂度大概就是o（m^n）。 题型 迷宫问题和洪水填充模型，但这类问题得数据量很小才能用dfs，更好的方法是用bfs。 一些简单的指数级枚举递归题目，比如P2036 PERKET|P2089 烤鸡 指数级枚举的代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void dfs(int x)//x表示当前位置,一般从1开始 { if(x\u0026gt;n) //n代表位置的总数 { //根据题目做一些操作 return; } for(int i=1;i\u0026lt;=m;i++)//m代表每个位置能选择m种方案 { arr[x]=1; //一般会开个数组代表当前位置的选择,1代表选择，0代表未考虑 dfs(x+1); arr[x]=0; //代表恢复 } //如果题目只有两种选择，选或者不选，也可以不用for //选 arr[x]=1; dfs(x+1); arr[x]=0; //不选 arr[x]=2; dfs(x+1); arr[x]=0; } 以P2036 PERKET为例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct pos { int bitter; int sour; }; struct pos a[20]; int st[20]; int n; int minn = 1e9; void dfs(int x); int main(void) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i].sour \u0026gt;\u0026gt; a[i].bitter; } dfs(1); cout \u0026lt;\u0026lt; minn \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } void dfs(int x) { if (x \u0026gt; n) { bool flag = false; int sum = 0; int mut = 1; for (int i = 1; i \u0026lt;= n; i++) { if (st[i] == 1) { sum += a[i].bitter; mut *= a[i].sour; flag = true; } } if (flag) { minn = min(minn, abs(sum - mut)); } return; } st[x] = 1; // 1代表选，2代表不选,0代表未考虑 dfs(x + 1);//这一题只有两种选择，所以直接这样 st[x] = 0; st[x] = 2; dfs(x + 1); st[x] = 0; } 排列型枚举 对于一个位置，有若干种方案选择，他选择了一种，接着下一个位置就只能选择剩下的方案，方案因此逐次递减 题型 N皇后问题（简单的版本是棋盘问题） 分析：\n1.将行视为位置，列视为选择，画出递归树\n2.使用排列枚举方式进行枚举，能够实现每行每列只放一个棋子\n3.使用一个一维数组来记录对于列的选择情况\n棋盘问题acwing1114 棋盘问题的代码模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 15; char g[N][N]; bool st[N]; // 记录已经选过的列 int n, m; // n为几阶方阵，m为棋数目 int res = 0; // 记录方案数 void dfs(int x, int cnt); // x代表第几行，从第一行开始，每个位置有n种选择，并且是排列枚举， // 根据st数组来判断这一列（即选择）是否已经被选过,cnt代表已经选了几个棋子 int main(void) { while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m) != EOF) { if (n == -1 \u0026amp;\u0026amp; m == -1) { break; } cin.ignore(); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i]); } res = 0; dfs(0, 0); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } void dfs(int x, int cnt) { if (cnt == m) { res++; return; } if (x \u0026gt; n - 1) { return; } for (int i = 0; i \u0026lt; n; i++) { if (!st[i] \u0026amp;\u0026amp; g[x][i] == \u0026#39;#\u0026#39;) { st[i] = true; dfs(x + 1, cnt + 1); st[i] = false; } } dfs(x + 1, cnt); // 表示这行我们不放棋子，直接进入下一行 } 八皇后问题：\n题面：\n会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 × 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。\n对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应,a有8个数字，第i个数表示第i行的皇后所处的位数。已经知道8皇后问题一共有92组解。\n现给出一个数b，要求输出第b个合法的八皇后串。串的排序按照字典序从小到大.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 105; bool col[N]; // 存储列状态 bool ls[N]; // 存储左对角线状态 bool rs[N]; // 存储右对角线状态，由于右对角线可能有负数，所以整体平移 int arr[N]; // 记录每行选了哪一列 int ans[100][N]; // 记录答案 void dfs(int x); // x代表当前到第几行 int cnt = 1; int main(void) { int k, b; cin \u0026gt;\u0026gt; k; dfs(1); while (k--) { cin \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= 8; i++) { cout \u0026lt;\u0026lt; ans[b][i]; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } void dfs(int x) { if (x \u0026gt; 8) { for (int i = 1; i \u0026lt;= 8; i++) { ans[cnt][i] = arr[i]; } cnt++; return; } for (int i = 1; i \u0026lt;= 8; i++) { if (!col[i] \u0026amp;\u0026amp; !ls[i + x] \u0026amp;\u0026amp; !rs[i - x + 8]) { col[i] = true; ls[i + x] = true; rs[i - x + 8] = true; arr[x] = i; dfs(x + 1); col[i] = false; ls[i + x] = false; rs[i - x + 8] = false; arr[x] = 0; } } } 分析：\n为何不用二维数组记录斜对角线？因为二维数组记录更适用于不会有回溯记录的情况，这题由于dfs会回溯很多次，所以用二维数组会大幅度增加时间复杂度，所以我们使用一维数组来记录。 rs数组记录右对角线时，因为右对角线可能有负数，所以整体平移，使得右对角线的范围为\u0026gt;=1 如何表示左斜角线和右斜角线？假设皇后在（2、4），对于（1，3）、（3，5）、（4、6）这些在右斜线上的点，都有y-x=定值，同理，左斜线为x+y=定值。于是，就可以得出 左斜角线：ls[i+j]=1;\n右斜角线：rs[i-j+n]=1; n即为行数，此处为8\n排列型枚举的代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int st[N]; //N代表位置的总数所能填写的最大值 void dfs(int x)// x代表当前位置，一般从1开始 { if(x\u0026gt;n) { //根据题目做一些操作 return; } for(int i=1;i\u0026lt;=m;i++)//m代表每个位置能选择m种方案 { if(!st[i]) { st[i]=1; arr[x]=1; dfs(x+1); arr[x]=0; //恢复 st[i]=0; } } } 组合型枚举 对于一个位置，有若干种方案选择，他选择了一种，接着下一个位置能选择的方案必须大于上一个位置选择的方案，这里的大于是指字典序，所以这类题会与数字和字母有关 例题P1025 代码模板（以P1025为例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // 组合枚举 void dfs(int x, int start, int sum); // x代表从位置几开始枚举，start代表枚举数字的起点 int n, k; int res = 0; int main(void) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; dfs(1, 1, 0); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } void dfs(int x, int start, int sum) { if (x \u0026gt; k) { if (sum == n) { res++; } return; } for (int i = start; sum + (k - x + 1) * i \u0026lt;= n; i++) { dfs(x + 1, i, sum + i); } } /*注意，这题如果不进行剪枝操作，会TLE，sum+(k-x+1)*i\u0026lt;=n是剪枝操作 这说的是，如果当前的和加上剩下的数大于n 那么就没有必要继续枚举了 因为我们的位置是要全选完的 所以这种情况绝对最后数会大于n，直接剪枝*/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void dfs(int x,int start)//x代表从位置几开始枚举，start代表枚举数字的起点 { if(x\u0026gt;n) { //根据题目做一些操作 return; } for(int i=start;i\u0026lt;=m;i++)//m代表每个位置能选择m种方案 { arr[x]=i; dfs(x+1,i+1); /*如果是要求下一个选的数大于等于上一个选的数 那么可以dfs（x+1，i）*/ arr[x]=0; //恢复 } } 广度优先搜索 广度优先搜索的特性： 用于图的查找算法（要求能用图表示出问题的关联性） BFS可以用于解决两类问题： 从A出发是否存在到达B的路径 DFS也可求 从A出发到达B的最短路径 DFS如果数据少也可以考虑 BFS是一种用空间换时间的算法，空间复杂度大概为o（2^h），h代表树的高度，2为每次分出来的支数，以二叉树为例 BFS使用的数据结构是队列，可以使用STL中的queue来实现 画出一个树状结构图，每一层都会有若干个节点，每个节点又会有若干个分支，bfs的思路就是从根节点（或者其他节点）开始，访问先访问其直接相连的子节点，若子节点不符合，再访问其子节点的子节点，按级别顺序（一层一层）依次访问，直到访问到目标节点 起始：将起点（源点，树的根节点）放入队列中 扩散：从队列中取出队头的结点，将它的相邻结点放入队列，不断重复这一步 终止：当队列为空时，说明我们遍历了所有的结点，整个图都被搜索了一遍 这种搜索方法，形象点说就像一个水波纹，从源点开始，一层一层的扩散，直到扩散到终点 通过队列实现广度优先搜索，那么队列就具有二段性1，以及单调性2 对于所有边长度相同的情况，比如地图的模型，bfs第一次遇到目标点，此时就一定是从根节点到目标节点的最短路径（因为每一次所有点都是向外扩张一步，你先遇到，一定就最短）。但是，如果是加权边3的话就会出问题了，bfs传回的是经过边数最少的解，但是因为加权了，这个解到根节点的距离不一定是最短的。比如1000+1000是只有两段，1+1+1+1有4段，由于BFS返回的是经过边数最少的解，所以会返回1000+1000的解，此时我们要采用dijkstra最短路算法4解决加权路径的最短路问题。 题型 迷宫问题 多元BFS 染色问题 flood fill 找连通块 有外界干扰的迷宫问题 双向广搜 状态压缩 双端队列广搜 例题： 迷宫问题 例题acwing844.走迷宫是经典模板题，然而要钱，所以题目平替用P1746\n因为都是一个思想，所以我们贴上acwing844的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; #define x first #define y second const int N = 110; int g[N][N]; int n, m; int dis[N][N]; // 存储每个点到起点的距离 int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; // 向量数组，四个方向 上右下左 queue\u0026lt;PII\u0026gt; q; // 存坐标 int bfs(int x1, int y1); int main(void) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; g[i][j]; } } int res = bfs(1, 1); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(int x1, int y1) { // 使用队列模拟广度优先搜索,从起点开始 memset(dis, -1, sizeof(dis)); // 初始化为-1，-1代表与起点不连通，即是1的位置 q.push({x1, y1}); dis[x1][y1] = 0; // 起始点为0 while (q.size()) { PII t = q.front(); // 取出队头 q.pop(); // 弹出 for (int i = 0; i \u0026lt; 4; i++) { int a = t.x + dx[i]; // 上右下左 int b = t.y + dy[i]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; m) // 越界 continue; if (g[a][b] != 0) continue; if (dis[a][b] \u0026gt; 0) continue; q.push({a, b}); /* 入队，根据上右下左，满足的条件的进去 然后以上右下左的顺序出队 假设入队了一个右的，一个下的， 右的先出队就把右的下一个能入队的入队，然后下的再出队 这样就保证了广度优先而不是深度优先, 即一层一层的出队，而不是一条路走到黑*/ dis[a][b] = dis[t.x][t.y] + 1; // 保证了距离是前一个能走的点的距离+1 if (a == n \u0026amp;\u0026amp; b == m) return dis[n][m]; } } return dis[n][m]; } 代码分析、一些常用的习惯：\n向量数组，如果我们要遍历四个方向，我们可以使用向量数组来遍历，这样可以减少代码量并且简洁，假如有斜上方向就是八个了，一般来说以上右下左的方式看，并且我们规定x指向下方，y指向右方（数学中的坐标系顺时针转90°） #define pair\u0026lt;int,int\u0026gt; PII ，这样就可以使用PII来代替pair\u0026lt;int,int\u0026gt;，可以简洁一些 memset，用于初始化数组，第一个参数是数组名，第二个参数是要赋的值，第三个参数是要赋的值的类型，系统用字节数量来判断，所以用sizeof（） 队列实现bfs，为何用队列？正如以上所说，我们需要一层层去遍历到所有结点，那么相邻结点的访问顺序如何确定呢？因此我们就需要一个数据结构去存储和操作，需要使先遍历到的结点先被存储，直到当前层都被存储之后，按照存储的先后顺序，先被存储的结点也会被先取出来，继续遍历他的子节点\u0026ndash;\u0026gt;综上所述，需要一种特点为先进先出的数据结构，也就是队列 例题:P1443 马的遍历\n题目分析：\n这一题与普通迷宫问题不同的是方向向量数组要变化，总共有八种方向选择，并且，这一题如果用STL会有样例过不了，如果确定思路没错，实现代码正确，但是会超时的话，我们就要自己手写队列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 450; int dis[N][N]; int n, m, x, y; int tt = 0, hh = 0; int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2}; int dy[] = {1, 2, 2, 1, -1, -2, -2, -1}; PII q[N * N]; void bfs(int x1, int y1); int main(void) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; bfs(x, y); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cout \u0026lt;\u0026lt; dis[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } void bfs(int x1, int y1) { memset(dis, -1, sizeof(dis)); q[0] = {x1, y1}; dis[x1][y1] = 0; while (hh \u0026lt;= tt) { PII t = q[hh++]; for (int i = 0; i \u0026lt; 8; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; m) continue; if (dis[a][b] \u0026gt;= 0) continue; dis[a][b] = dis[t.first][t.second] + 1; q[++tt] = {a, b}; } } } 手写队列的要点：\n队列的初始化：tt=-1，hh=0 tt即队尾，hh为队头，题目tt=0是因为我们已经初始化进去一个坐标了，队列里本来就有一个 入队：q[++tt]={a,b} 出队：auto t=q[hh++]; 判空：while(hh\u0026lt;=tt) 若是hh\u0026gt;tt就说明队列为空 多元BFS 例题：p1332血色先锋队\n题目分析：\n题目中瘟疫源，即bfs的起点有好几个，此时就要想到，bfs的思想是一层一层的遍历，把起点也算一层，那么我们就需要把所有的起点都入队，自然就能实现多元bfs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 550; queue\u0026lt;PII\u0026gt; q; int dis[N][N]; int n, m, a, b, c, d; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; void bfs(void); int main(void) { memset(dis, -1, sizeof(dis)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = 0; i \u0026lt; a; i++) { int x1, y1; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1); q.push({x1, y1}); dis[x1][y1] = 0; } bfs(); for (int i = 1; i \u0026lt;= b; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d\\n\u0026#34;, dis[c][d]); } return 0; } void bfs(void) { while (q.size()) { PII t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int x = t.first + dx[i]; int y = t.second + dy[i]; if (x \u0026lt; 1 || x \u0026gt; n || y \u0026lt; 1 || y \u0026gt; m) continue; if (dis[x][y] \u0026gt;= 0) /*不需要额外条件判断 画个图就能发现不会出现一个格子上第一次的距离会比第二次 的距离大的情况。第一次标记得到的距离一定会是最小 */ { continue; } dis[x][y] = dis[t.first][t.second] + 1; q.push({x, y}); } } } 染色问题 例题: P1162 填涂颜色\n题目分析：\n此题要把1围成的一个圈内的0都变为2，那么如何判定圈内0和圈外0呢？我们可以用一个二维状态数组，首先用bfs把圈外的0都标记为true，然后在主函数中遍历一遍地图，把为0并且状态数组为false的换为2即可。但是，这类问题要注意边界问题，我们一般起点以（1，1）开始，但是若是坐标（1，1）的点就是1，就不对了。并且，也有可能会出现最上面一些0，中间是一块1圈，最下面还有0，这种情况普通bfs也够不到那些下面的0。\n因此，我们可以把地图扩大一圈，假设地图边界为1\u0026ndash;n，那我们就可以搜索0\u0026ndash;n+1，这样就保证了可以把所有圈外的0标记为true，之后输出的时候再用1-n输出即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 40; int g[N][N]; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; queue\u0026lt;PII\u0026gt; q; bool st[N][N]; void bfs(int x1, int y1); int n; int main(void) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); } } bfs(0, 0); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (g[i][j] == 0 \u0026amp;\u0026amp; st[i][j] == false) { g[i][j] = 2; } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { printf(\u0026#34;%d \u0026#34;, g[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } void bfs(int x1, int y1) { q.push({x1, y1}); st[x1][y1] = true; while (q.size()) { PII t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 0 || a \u0026gt; n + 1 || b \u0026lt; 0 || b \u0026gt; n + 1) continue; if (g[a][b] == 1) continue; if (st[a][b] == true) continue; st[a][b] = true; q.push({a, b}); } } } flood fill 连通块问题 例题:P1451求细胞数量\n题目分析:\n这一题要找非0数字的联通块数，所谓联通块，就是指图中一块都是相同类型的点，本题中连通块的定义为沿连通块数字上下左右若还是连通块数字则为同一连通块,那么我们确定了方向向量是四个方向（有时会是8个方向）,要确定一个连通块，我们就可以分两个步骤，第一步是找到一个连通块的起始点，第二步是从这个起始点开始bfs把所有符合条件的点标记为true，然后连通块数++。如此循环直到所有符合条件点被标记为true，循环结束。标记为true是为了第一步找到的起始点还在以及搜过的连通块中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 110; typedef pair\u0026lt;int, int\u0026gt; PII; char g[N][N]; bool st[N][N]; queue\u0026lt;PII\u0026gt; q; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int n, m; int res = 0; void bfs(int x1, int y1); int main(void) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while (getchar() != \u0026#39;\\n\u0026#39;) { continue; } for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i] + 1); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (g[i][j] != \u0026#39;0\u0026#39; \u0026amp;\u0026amp; st[i][j] == false) { bfs(i, j); res++; } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } void bfs(int x1, int y1) { q.push({x1, y1}); st[x1][y1] = true; while (q.size()) { PII t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; m) { continue; } if (g[a][b] == \u0026#39;0\u0026#39;) { continue; } if (st[a][b] == true) { continue; } q.push({a, b}); st[a][b] = true; } } } 小技巧：若要从g[1][1]开始输入字符串，可以用g[i]+1。\n有外界干扰的迷宫问题 例题:P2895 Meteor Shower S 天降陨石\n题目分析:\n这一题是一道迷宫问题，求出起点到终点的最短路径，但在不同时间段会有陨石干扰，即到达某点的时间不能超过陨石到达的时间。\n那么，我们就能分析出什么点是能走的：\n1.该点始终都没有被陨石砸到\n2.该点未被走过\n3.贝蒂走到该点的时间小于陨石砸到该点的时间\n那么，我们可以开两个二维数组，一个预处理记录所有陨石砸到某点的时间，一个在bfs用于记录贝蒂走到某点的时间\n最短时间在哪找到？这个点始终不会被陨石砸到，只要找到第一个这个点就是最短时间了\n并且，这一题要关注到陨石砸下的位置是可能重复的，所以我们要取所有陨石砸下的时间的最小值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; queue\u0026lt;PII\u0026gt; qt; const int N = 350; int g[N][N]; // 记录了陨石砸在地图上的坐标以及时间点,0代表没被砸到,大于0代表被砸到的时间点 int tim[N][N]; // 记录了每个点到起点需要的时间 // 如何判断一个点是否可以走，dis[x][y]\u0026gt;=g[x][y] 说明不能走 int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int m; int bfs(int x1, int y1); int main(void) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); memset(g, 0x3f, sizeof(g)); for (int i = 1; i \u0026lt;= m; i++) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); g[a][b] = min(g[a][b], c); for (int j = 0; j \u0026lt; 4; j++) { int p = a + dx[j]; int q = b + dy[j]; if (p \u0026lt; 0 || p \u0026gt; 301 || q \u0026lt; 0 || q \u0026gt; 301) { continue; } g[p][q] = min(g[p][q], c); } } int res = bfs(0, 0); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } int bfs(int x1, int y1) { qt.push({x1, y1}); tim[x1][y1] = 0; while (qt.size()) { PII t = qt.front(); qt.pop(); for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 0 || b \u0026lt; 0) { continue; } if (tim[a][b]) { continue; } if (tim[t.first][t.second] + 1 \u0026gt;= g[a][b]) { continue; } tim[a][b] = tim[t.first][t.second] + 1; qt.push({a, b}); if (g[a][b] \u0026gt; 1e9) { return tim[a][b]; } } } return -1; } 小技巧：memset(数组名，0x3f,sizeof(数组名))，可以把数组初始化为无穷大，因为memset是按字节赋值的. 4个字节均为0x3f时，0x3f3f3f3f的十进制是1061109567，也就是10^ 9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。（如果数据远大于1e9就不行了）\nvoid memset(void *s, int ch, size_t n);\n函数解释：\n将s中前n个字节 （typedef unsigned int size_t ）用 ch\n替换并返回 s 。 其实这里面的ch就是ascii为ch的字符；\n将s所指向的某一块内存中的前n个 字节的内容全部设置为ch指定的ASCII值\n双向广搜（满足条件可以使用的优化） 与普通的BFS不同，双向BFS维护的队列中分别有起点搜索出的点和终点搜索出的点，两个点的搜索交替进行。同时，用数组或是哈希表记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束\n使用条件：当起点和终点状态已知，则可以使用\n优点：可以减少时间\n缺点：必须确定起点和终点，在对状态进行标记时往往涉及状态的压缩\n例题:P1746离开中山路\n运用数组的双向广搜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;bits/stdc++.h\u0026gt; //双向广搜优化 using namespace std; const int N = 1100; typedef pair\u0026lt;int, int\u0026gt; PII; int n; char g[N][N]; int dist[N][N]; int vis[N][N]; queue\u0026lt;PII\u0026gt; qt; int a, b, c, d; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int bfs(void); int main(void) { cin \u0026gt;\u0026gt; n; cin.ignore(); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i] + 1); } cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int res = bfs(); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(void) { memset(dist, -1, sizeof(dist)); // dist存（i，j）到起点的距离 memset(vis, -1, sizeof(vis)); // vis[i][j]表示(i,j)的标记 1是起点开始搜，2是终点开始搜 dist[a][b] = 0; dist[c][d] = 0; vis[a][b] = 1, vis[c][d] = 2; qt.push({a, b}); qt.push({c, d}); while (qt.size()) { PII t = qt.front(); qt.pop(); for (int i = 0; i \u0026lt; 4; i++) { int x = t.first + dx[i]; int y = t.second + dy[i]; if (x \u0026lt; 1 || x \u0026gt; n || y \u0026lt; 1 || y \u0026gt; n) continue; if (g[x][y] != \u0026#39;0\u0026#39;) continue; if (vis[x][y] + vis[t.first][t.second] == 3) // 说明此时有个交点，起点与终点的搜索相遇 { return dist[x][y] + dist[t.first][t.second] + 1; } if (dist[x][y] \u0026gt;= 0) { continue; } dist[x][y] = dist[t.first][t.second] + 1; // 拓展队头的子节点 if (vis[x][y] == -1) // vis为-1就说明这个点没有被拓展过，那么就根据上一个点的vis进行标记 { vis[x][y] = vis[t.first][t.second]; } qt.push({x, y}); } } return -1; } 例题二：p1379 八数码难题\n运用哈希表的双向广搜，并且运用了状态压缩的方法\n题目分析:\n根据题目，我们可以画出搜索树，但是问题是如何表示状态呢，用二维数组表示状态会十分麻烦，不过题目给了我们提示，使用一维的字符串，这就是状态压缩，将二维降维为一维,同时，我们可以用哈希表记录状态是否被访问过，还有，这题给出了起点和终点，所以我们还可以双向广搜（双向广搜作为一个优化的办法，如果题目数据不大，可以不用，毕竟代码量多容易错）\n状态压缩：首先，我们要明确用一维字符串进行状态的存储，假如要进行变换，那就要用二维数组进行，所以，我们要解决一维变二维和二维变一维的问题\n题目中规定了矩阵是3*3的，那么，用一维数组下标来表示二维数组的行和列，就是一维数组下标/3\u0026ndash;\u0026gt;行,一维数组下标%3\u0026ndash;\u0026gt;列(注意这里以(0,0)开头)\n题目只要求移动0，所以我们就可以找到0的位置(string.find(\u0026lsquo;0\u0026rsquo;)),然后再表示即可 若要将二维下标转为一维，则是一维下标=二维行下标*3+二维列下标.\n哈希表：哈希表其实就是stl中的map或unordered_map容器，我们把每次的状态作为key-键，变换次数作为值，这样就可以记录状态是否被访问过\n双向广搜：这里要注意的就是记录情况要用哈希表\n无优化的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string end1 = \u0026#34;123804765\u0026#34;; // 状态压缩 unordered_map\u0026lt;string, int\u0026gt; dist; // 哈希表 queue\u0026lt;string\u0026gt; q; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; // 上下左右四个方向 int bfs(string start); int main() { string start; cin \u0026gt;\u0026gt; start; int res = bfs(start); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(string start) { q.push(start); dist[start] = 0; while (q.size()) { auto t = q.front(); q.pop(); if (t == end1) { return dist[t]; } int distance = dist[t]; // 取出当前状态的距离 // 一维数组下标转换为二维数组下标（找到0的位置--\u0026gt;一维数组下标--\u0026gt;二维数组下标） int ta = t.find(\u0026#39;0\u0026#39;); int tx = ta / 3; // 实现字符串转换为3*3的矩阵（这个矩阵是从(0,0)开始的) int ty = ta % 3; // tx第几行，ty第几列 for (int i = 0; i \u0026lt; 4; i++) { int a = tx + dx[i]; int b = ty + dy[i]; if (a \u0026lt; 0 || a \u0026gt;= 3 || b \u0026lt; 0 || b \u0026gt;= 3) continue; int temp = a * 3 + b; // 实现二维数组下标转换为一维数组下标 swap(t[ta], t[temp]); // 如果这个状态没有出现过，则加入队列，并计算距离 if (!dist.count(t)) // count函数 看map中有没有key值为t的元素，如果有则返回1，没有则返回0 { dist[t] = distance + 1; q.push(t); } swap(t[ta], t[temp]); // 恢复现场,为下个方向做准备 } } return -1; } 使用双向广搜的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string end1 = \u0026#34;123804765\u0026#34;; unordered_map\u0026lt;string, int\u0026gt; dist; unordered_map\u0026lt;string, int\u0026gt; st; // 1代表起点标记，2代表终点标记 queue\u0026lt;string\u0026gt; q; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; int bfs(string start); int main(void) { string start; cin \u0026gt;\u0026gt; start; int res = 0; if (start == end1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } res = bfs(start); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int bfs(string start) { q.push(start); dist[start] = 0; st[start] = 1; q.push(end1); dist[end1] = 0; st[end1] = 2; while (q.size()) { auto t = q.front(); q.pop(); int flag = st[t]; // 取出当前状态的标记 int distance = dist[t]; // 取出当前状态的距离 int ta = t.find(\u0026#39;0\u0026#39;); int tx = ta / 3; int ty = ta % 3; for (int i = 0; i \u0026lt; 4; i++) { int c = tx + dx[i]; int d = ty + dy[i]; if (c \u0026lt; 0 || c \u0026gt;= 3 || d \u0026lt; 0 || d \u0026gt;= 3) continue; int temp = c * 3 + d; swap(t[ta], t[temp]); if (st[t] + flag == 3) { return dist[t] + distance + 1; } if (!dist.count(t)) { dist[t] = distance + 1; st[t] = flag; q.push(t); } swap(t[ta], t[temp]); } } return 0; } 注意事项：\n关于map与unordered_map，他们区别在于map会对键值进行排序，按照字典序从小到大，unordered_map是无序的 关于map.count(t)函数，如果map中存在key值为t的函数，则返回1，否则返回0，注意由于map和unordered_map具有互异性，所以才只返回1，这可以用来判断状态是否被访问过 map与unordered_map在未被访问时是没有默认值的，而一旦有涉及到map[t]的操作时，就会自动创建一个key值为t的元素，并赋予默认值，所以在使用map时，如果要判断状态是否被访问过，就不能直接用map[t]，而是要用map.count(t) 状态压缩 状态压缩的目的是将一个二维的状态转为一维，这样记录状态会十分方便，涉及到状态压缩一般就会使用字符串和哈希表\n例题：P2730 [USACO3.2] 魔板 Magic Squares\n题目分析:\n这题的难点有三个，第一个是如何表示状态，第二个是如何输出到达目标状态使用的所有基本操作，第三个是如何实现这三种基本操作\n状态表示：这题是一个2*4的矩阵，显然我们可以用状态压缩表示状态，关键是如何进行三种基本操作。 如何输出到达目标状态使用的所有基本操作：首先我们要知道如何记录到达一个状态所用的基本操作，我们可以用哈希表记录，那么键为当前状态，并且，我们还可以再记录上一个状态，方便输出，值就为pair\u0026lt;char,string\u0026gt;\u0026ndash;\u0026gt;first为基本操作，second为上一个状态,如此只要从目标状态开始，不断地回溯到起点，就可以得到逆序的基本操作表，再反转函数用一下就好了 如何实现这三种基本操作：这题的三种基本操作，就是中心顺时针旋转，最后一列迁移到第一列，上下交换，这三种操作把涉及到了大部分元素，所以我们无法像八数码那样部分的转换，因此我们开一个二维数组专门进行，我们可以用一个get1函数实现一维变二维，再用一个get2函数实现二维变一维。然后再用3个函数分别实现这三种基本操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; unordered_map\u0026lt;string, int\u0026gt; dist; // 存到当前状态需要几步 unordered_map\u0026lt;string, pair\u0026lt;char, string\u0026gt;\u0026gt; pre; // 存从哪一个状态转移过来，而且要存A还是B还是C操作 queue\u0026lt;string\u0026gt; q; char g[10][10]; // 把一维字符串转为二维数组 void set1(string t) { for (int i = 0; i \u0026lt; 4; i++) { g[0][i] = t[i]; } for (int i = 3, j = 4; i \u0026gt;= 0; i--, j++) { g[1][i] = t[j]; } } // 把二维数组转换为一维字符串 string get1() { string res; for (int i = 0; i \u0026lt; 4; i++) { res += g[0][i]; } for (int i = 3; i \u0026gt;= 0; i--) { res += g[1][i]; } return res; } int bfs(string start, string end1); string move0(string t); string move1(string t); string move2(string t); int main(void) { int x; string start, end1; for (int i = 1; i \u0026lt;= 8; i++) //考虑到题目中有空格，所以要把数字转换为字符 { cin \u0026gt;\u0026gt; x; end1 += x + \u0026#39;0\u0026#39;; } for (int i = 1; i \u0026lt;= 8; i++) { start += i + \u0026#39;0\u0026#39;; } int res = bfs(start, end1); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; string res2; while (end1 != start) { res2 += pre[end1].first; // 这样得出的是逆序的操作表 end1 = pre[end1].second; } reverse(res2.begin(), res2.end()); // 反转，使用迭代器 if (res2.size()) { cout \u0026lt;\u0026lt; res2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } int bfs(string start, string end1) { q.push(start); dist[start] = 0; while (q.size()) { auto t = q.front(); q.pop(); if (t == end1) // 假如基础状态就是目标状态的情况这个if会被使用 { return dist[end1]; } string m[3]; m[0] = move0(t); m[1] = move1(t); m[2] = move2(t); for (int i = 0; i \u0026lt; 3; i++) { string s = m[i]; if (!dist.count(s)) { dist[s] = dist[t] + 1; pre[s] = {char(i + \u0026#39;A\u0026#39;), t}; //(用哪个操作过来的，变换后的串) if (s == end1) { return dist[end1]; } q.push(s); } } } return -1; } string move0(string t) // A变换 { set1(t); for (int i = 0; i \u0026lt; 4; i++) { swap(g[0][i], g[1][i]); } return get1(); } string move1(string t) // B变换 { set1(t); // 通过交换实现 for (int i = 3; i \u0026gt;= 1; i--) { swap(g[0][i], g[0][i - 1]); swap(g[1][i], g[1][i - 1]); } return get1(); } string move2(string t) // C变换 { set1(t); // 把中间四个数中左上角的数存起来，然后直接转一圈 char temp = g[0][1]; g[0][1] = g[1][1]; g[1][1] = g[1][2]; g[1][2] = g[0][2]; g[0][2] = temp; return get1(); } 双端队列广搜 与普通广搜不同的是，双端队列广搜使用的容器是deque双端队列 使用条件：状态只有两种，保证单调性\n例题:P4554 小明的游戏\n题目分析:\n根据题目，想要花费最少就要先走完所有费用0的格子,然后再走费用为1的格子，我们把费用0和费用1的格子视为两种状态，那么就符合了队列的两段性，但是如果只是普通队列，我们没办法使费用0的格子先全部走完，再走费用1的格子，这时我们可以用双端队列，将费用0的格子从队头入队，费用1的格子从对尾入队，这样就可以使费用0的格子全部走完再走费用1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 510; char g[N][N]; int dis[N][N]; int n, m; int x, x2, y, y2; deque\u0026lt;PII\u0026gt; q; int dx[] = {-1, 0, 1, 0}; int dy[] = {0, 1, 0, -1}; int bfs(int x, int y); int main(void) { while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m, n || m) { for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s\u0026#34;, g[i]); } memset(dis, -1, sizeof(dis)); q.clear(); cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int res = bfs(x, y); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } int bfs(int x, int y) { q.push_back({x, y}); dis[x][y] = 0; while (q.size()) { PII t = q.front(); q.pop_front(); char ch = g[t.first][t.second]; for (int i = 0; i \u0026lt; 4; i++) { int a = t.first + dx[i]; int b = t.second + dy[i]; if (a \u0026lt; 0 || a \u0026gt;= n || b \u0026lt; 0 || b \u0026gt;= m) continue; if (dis[a][b] \u0026gt;= 0) { continue; } if (g[a][b] == ch) { dis[a][b] = dis[t.first][t.second] + 0; // 状态不会变 q.push_front({a, b}); } if (g[a][b] != ch) { dis[a][b] = dis[t.first][t.second] + 1; // 状态会增加 q.push_back({a, b}); } if (a == x2 \u0026amp;\u0026amp; b == y2) { return dis[x2][y2]; } } } return -1; } 搜索总结 深度优先搜索的关键词：\n一条路走到黑 回溯 栈 剪枝 广度优先搜索的关键词：\n水波纹，一层一层 不存在回溯，可以使用额外的数据结构进行记录以实现回溯 队列 图，迷宫，最短路 额外知识补充 曼哈顿距离:\n曼哈顿距离（Manhattan Distance）是由十九世纪的赫尔曼·闵可夫斯基所创词汇 ，是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。\n曼哈顿距离——两点在南北方向上的距离加上在东西方向上的距离，即d(i,j)=|xi-xj|+|yi-yj|。（横平竖直的距离）\n还有一种常用距离是欧几里得距离，欧几里得距离——两点在欧几里得空间中的距离，即d(i,j)=sqrt((xi-xj)^2+(yi-yj)^2)。（斜着的距离）\n任何时刻，队列中最多存在两种状态\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n前一段状态为x，后一段状态为x+1\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n加权边的意思是给边长度赋值，原本边长度都默认为1，结果加权边给他们赋不同的值，100，500，600这样子\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ndijkstra算法可以在图论的相关学习中学到\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-12-15T00:00:00Z","image":"https://baozi.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%90%9C%E7%B4%A2/huosuzhanshiba_hu13603702406361595890.jpg","permalink":"https://baozi.github.io/p/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%90%9C%E7%B4%A2/","title":"算法学习-搜索"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://baozi.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://baozi.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://baozi.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://baozi.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://baozi.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://baozi.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://baozi.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://baozi.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://baozi.github.io/p/emoji-support/","title":"Emoji Support"}]